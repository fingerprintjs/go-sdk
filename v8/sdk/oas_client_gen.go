// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// DeleteVisitorData invokes deleteVisitorData operation.
	//
	// Request deleting all data associated with the specified visitor ID. This API is useful for
	// compliance with privacy regulations.
	// ### Which data is deleted?
	// - Browser (or device) properties
	// - Identification requests made from this browser (or device)
	// #### Browser (or device) properties
	// - Represents the data that Fingerprint collected from this specific browser (or device) and
	// everything inferred and derived from it.
	// - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and
	// it will no longer be used to identify this browser (or device) for your [Fingerprint
	// Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).
	// #### Identification requests made from this browser (or device)
	// - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or
	// 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.
	// com/docs/regions#data-retention).
	// - Upon request to delete, the identification requests that were made by this browser
	// - Within the past 10 days are deleted within 24 hrs.
	// - Outside of 10 days are allowed to purge as per your data retention period.
	// ### Corollary
	// After requesting to delete a visitor ID,
	// - If the same browser (or device) requests to identify, it will receive a different visitor ID.
	// - If you request [`/v4/events` API](https://dev.fingerprint.com/reference/getevent) with an
	// `event_id` that was made outside of the 10 days, you will still receive a valid response.
	// ### Interested?
	// Please [contact our support team](https://fingerprint.com/support/) to enable it for you.
	// Otherwise, you will receive a 403.
	//
	// DELETE /visitors/{visitor_id}
	DeleteVisitorData(ctx context.Context, params DeleteVisitorDataParams) (DeleteVisitorDataRes, error)
	// GetEvent invokes getEvent operation.
	//
	// Get a detailed analysis of an individual identification event, including Smart Signals.
	// Use `event_id` as the URL path parameter. This API method is scoped to a request, i.e. all
	// returned information is by `event_id`.
	//
	// GET /events/{event_id}
	GetEvent(ctx context.Context, params GetEventParams) (GetEventRes, error)
	// SearchEvents invokes searchEvents operation.
	//
	// ## Search
	// The `/v4/events` endpoint provides a convenient way to search for past events based on specific
	// parameters. Typical use cases and queries include:
	// - Searching for events associated with a single `visitor_id` within a time range to get historical
	// behavior of a visitor.
	// - Searching for events associated with a single `linked_id` within a time range to get all events
	// associated with your internal account identifier.
	// - Excluding all bot traffic from the query (`good` and `bad` bots)
	// If you don't provide `start` or `end` parameters, the default search range is the **last 7 days**.
	// ### Filtering events with the `suspect` flag
	// The `/v4/events` endpoint unlocks a powerful method for fraud protection analytics. The `suspect`
	// flag is exposed in all events where it was previously set by the update API.
	// You can also apply the `suspect` query parameter as a filter to find all potentially fraudulent
	// activity that you previously marked as `suspect`. This helps identify patterns of fraudulent
	// behavior.
	// ### Environment scoping
	// If you use a secret key that is scoped to an environment, you will only get events associated with
	// the same environment. With a workspace-scoped environment, you will get events from all
	// environments.
	// Smart Signals not activated for your workspace or are not included in the response.
	//
	// GET /events
	SearchEvents(ctx context.Context, params SearchEventsParams) (SearchEventsRes, error)
	// UpdateEvent invokes updateEvent operation.
	//
	// Change information in existing events specified by `event_id` or *flag suspicious events*.
	// When an event is created, it can be assigned `linked_id` and `tags` submitted through the JS agent
	// parameters.
	// This information might not have been available on the client initially, so the Server API permits
	// updating these attributes after the fact.
	// **Warning** It's not possible to update events older than one month.
	// **Warning** Trying to update an event immediately after creation may temporarily result in an
	// error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across
	// our systems. In such a case, simply retry the request.
	//
	// PATCH /events/{event_id}
	UpdateEvent(ctx context.Context, request *EventUpdate, params UpdateEventParams) (UpdateEventRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// DeleteVisitorData invokes deleteVisitorData operation.
//
// Request deleting all data associated with the specified visitor ID. This API is useful for
// compliance with privacy regulations.
// ### Which data is deleted?
// - Browser (or device) properties
// - Identification requests made from this browser (or device)
// #### Browser (or device) properties
// - Represents the data that Fingerprint collected from this specific browser (or device) and
// everything inferred and derived from it.
// - Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and
// it will no longer be used to identify this browser (or device) for your [Fingerprint
// Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).
// #### Identification requests made from this browser (or device)
// - Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or
// 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.
// com/docs/regions#data-retention).
// - Upon request to delete, the identification requests that were made by this browser
// - Within the past 10 days are deleted within 24 hrs.
// - Outside of 10 days are allowed to purge as per your data retention period.
// ### Corollary
// After requesting to delete a visitor ID,
// - If the same browser (or device) requests to identify, it will receive a different visitor ID.
// - If you request [`/v4/events` API](https://dev.fingerprint.com/reference/getevent) with an
// `event_id` that was made outside of the 10 days, you will still receive a valid response.
// ### Interested?
// Please [contact our support team](https://fingerprint.com/support/) to enable it for you.
// Otherwise, you will receive a 403.
//
// DELETE /visitors/{visitor_id}
func (c *Client) DeleteVisitorData(ctx context.Context, params DeleteVisitorDataParams) (DeleteVisitorDataRes, error) {
	res, err := c.sendDeleteVisitorData(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVisitorData(ctx context.Context, params DeleteVisitorDataParams) (res DeleteVisitorDataRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/visitors/"
	{
		// Encode "visitor_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "visitor_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VisitorID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, DeleteVisitorDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVisitorDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEvent invokes getEvent operation.
//
// Get a detailed analysis of an individual identification event, including Smart Signals.
// Use `event_id` as the URL path parameter. This API method is scoped to a request, i.e. all
// returned information is by `event_id`.
//
// GET /events/{event_id}
func (c *Client) GetEvent(ctx context.Context, params GetEventParams) (GetEventRes, error) {
	res, err := c.sendGetEvent(ctx, params)
	return res, err
}

func (c *Client) sendGetEvent(ctx context.Context, params GetEventParams) (res GetEventRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/events/"
	{
		// Encode "event_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "event_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EventID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ruleset_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ruleset_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RulesetID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, GetEventOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchEvents invokes searchEvents operation.
//
// ## Search
// The `/v4/events` endpoint provides a convenient way to search for past events based on specific
// parameters. Typical use cases and queries include:
// - Searching for events associated with a single `visitor_id` within a time range to get historical
// behavior of a visitor.
// - Searching for events associated with a single `linked_id` within a time range to get all events
// associated with your internal account identifier.
// - Excluding all bot traffic from the query (`good` and `bad` bots)
// If you don't provide `start` or `end` parameters, the default search range is the **last 7 days**.
// ### Filtering events with the `suspect` flag
// The `/v4/events` endpoint unlocks a powerful method for fraud protection analytics. The `suspect`
// flag is exposed in all events where it was previously set by the update API.
// You can also apply the `suspect` query parameter as a filter to find all potentially fraudulent
// activity that you previously marked as `suspect`. This helps identify patterns of fraudulent
// behavior.
// ### Environment scoping
// If you use a secret key that is scoped to an environment, you will only get events associated with
// the same environment. With a workspace-scoped environment, you will get events from all
// environments.
// Smart Signals not activated for your workspace or are not included in the response.
//
// GET /events
func (c *Client) SearchEvents(ctx context.Context, params SearchEventsParams) (SearchEventsRes, error) {
	res, err := c.sendSearchEvents(ctx, params)
	return res, err
}

func (c *Client) sendSearchEvents(ctx context.Context, params SearchEventsParams) (res SearchEventsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pagination_key" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pagination_key",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PaginationKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "visitor_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "visitor_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VisitorID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Bot.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ip_address" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ip_address",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IPAddress.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "asn" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "asn",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Asn.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "linked_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "linked_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LinkedID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.URL.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bundle_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bundle_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BundleID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "package_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "package_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PackageName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "origin" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "origin",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Origin.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.End.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "reverse" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "reverse",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Reverse.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "suspect" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "suspect",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Suspect.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vpn" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vpn",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Vpn.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "virtual_machine" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "virtual_machine",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VirtualMachine.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tampering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tampering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tampering.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "anti_detect_browser" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "anti_detect_browser",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AntiDetectBrowser.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "incognito" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "incognito",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Incognito.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "privacy_settings" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "privacy_settings",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PrivacySettings.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "jailbroken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "jailbroken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Jailbroken.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "frida" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "frida",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Frida.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "factory_reset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "factory_reset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FactoryReset.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cloned_app" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cloned_app",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClonedApp.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "emulator" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "emulator",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Emulator.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "root_apps" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "root_apps",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RootApps.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vpn_confidence" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vpn_confidence",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VpnConfidence.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "min_suspect_score" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_suspect_score",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinSuspectScore.Get(); ok {
				return e.EncodeValue(conv.Float32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "developer_tools" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "developer_tools",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeveloperTools.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location_spoofing" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location_spoofing",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LocationSpoofing.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mitm_attack" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mitm_attack",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MitmAttack.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "proxy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "proxy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Proxy.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sdk_version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sdk_version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SdkVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sdk_platform" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sdk_platform",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SdkPlatform.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Environment != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Environment {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "proximity_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "proximity_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProximityID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "total_hits" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "total_hits",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TotalHits.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tor_node" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tor_node",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TorNode.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, SearchEventsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEvent invokes updateEvent operation.
//
// Change information in existing events specified by `event_id` or *flag suspicious events*.
// When an event is created, it can be assigned `linked_id` and `tags` submitted through the JS agent
// parameters.
// This information might not have been available on the client initially, so the Server API permits
// updating these attributes after the fact.
// **Warning** It's not possible to update events older than one month.
// **Warning** Trying to update an event immediately after creation may temporarily result in an
// error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across
// our systems. In such a case, simply retry the request.
//
// PATCH /events/{event_id}
func (c *Client) UpdateEvent(ctx context.Context, request *EventUpdate, params UpdateEventParams) (UpdateEventRes, error) {
	res, err := c.sendUpdateEvent(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEvent(ctx context.Context, request *EventUpdate, params UpdateEventParams) (res UpdateEventRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/events/"
	{
		// Encode "event_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "event_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EventID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UpdateEventOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
