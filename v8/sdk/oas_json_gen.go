// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes Architecture as json.
func (s Architecture) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes Architecture from json.
func (s *Architecture) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Architecture to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Architecture(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Architecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Architecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Audio as json.
func (s Audio) Encode(e *jx.Encoder) {
	unwrapped := float64(s)

	e.Float64(unwrapped)
}

// Decode decodes Audio from json.
func (s *Audio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Audio to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Audio(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Audio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Audio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("provider")
		e.Str(s.Provider)
	}
	{
		if s.ProviderURL.Set {
			e.FieldStart("provider_url")
			s.ProviderURL.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("identity")
		s.Identity.Encode(e)
	}
	{
		e.FieldStart("confidence")
		s.Confidence.Encode(e)
	}
}

var jsonFieldsNameOfBotInfo = [6]string{
	0: "category",
	1: "provider",
	2: "provider_url",
	3: "name",
	4: "identity",
	5: "confidence",
}

// Decode decodes BotInfo from json.
func (s *BotInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Provider = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "provider_url":
			if err := func() error {
				s.ProviderURL.Reset()
				if err := s.ProviderURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "identity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Identity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identity\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotInfo) {
					name = jsonFieldsNameOfBotInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotInfoConfidence as json.
func (s BotInfoConfidence) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BotInfoConfidence from json.
func (s *BotInfoConfidence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotInfoConfidence to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BotInfoConfidence(v) {
	case BotInfoConfidenceLow:
		*s = BotInfoConfidenceLow
	case BotInfoConfidenceMedium:
		*s = BotInfoConfidenceMedium
	case BotInfoConfidenceHigh:
		*s = BotInfoConfidenceHigh
	default:
		*s = BotInfoConfidence(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotInfoConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotInfoConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotInfoIdentity as json.
func (s BotInfoIdentity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BotInfoIdentity from json.
func (s *BotInfoIdentity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotInfoIdentity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BotInfoIdentity(v) {
	case BotInfoIdentityVerified:
		*s = BotInfoIdentityVerified
	case BotInfoIdentitySigned:
		*s = BotInfoIdentitySigned
	case BotInfoIdentitySpoofed:
		*s = BotInfoIdentitySpoofed
	case BotInfoIdentityUnknown:
		*s = BotInfoIdentityUnknown
	default:
		*s = BotInfoIdentity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotInfoIdentity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotInfoIdentity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotResult as json.
func (s BotResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BotResult from json.
func (s *BotResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BotResult(v) {
	case BotResultBad:
		*s = BotResultBad
	case BotResultGood:
		*s = BotResultGood
	case BotResultNotDetected:
		*s = BotResultNotDetected
	default:
		*s = BotResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotType as json.
func (s BotType) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BotType from json.
func (s *BotType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotType to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BotType(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BrowserDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BrowserDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("browser_name")
		e.Str(s.BrowserName)
	}
	{
		e.FieldStart("browser_major_version")
		e.Str(s.BrowserMajorVersion)
	}
	{
		e.FieldStart("browser_full_version")
		e.Str(s.BrowserFullVersion)
	}
	{
		e.FieldStart("os")
		e.Str(s.Os)
	}
	{
		e.FieldStart("os_version")
		e.Str(s.OsVersion)
	}
	{
		e.FieldStart("device")
		e.Str(s.Device)
	}
}

var jsonFieldsNameOfBrowserDetails = [6]string{
	0: "browser_name",
	1: "browser_major_version",
	2: "browser_full_version",
	3: "os",
	4: "os_version",
	5: "device",
}

// Decode decodes BrowserDetails from json.
func (s *BrowserDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BrowserDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "browser_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BrowserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_name\"")
			}
		case "browser_major_version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BrowserMajorVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_major_version\"")
			}
		case "browser_full_version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BrowserFullVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_full_version\"")
			}
		case "os":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Os = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "os_version":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OsVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os_version\"")
			}
		case "device":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Device = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BrowserDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBrowserDetails) {
					name = jsonFieldsNameOfBrowserDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BrowserDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BrowserDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BundleId as json.
func (s BundleId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BundleId from json.
func (s *BundleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BundleId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BundleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Canvas) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Canvas) encodeFields(e *jx.Encoder) {
	{
		if s.Winding.Set {
			e.FieldStart("winding")
			s.Winding.Encode(e)
		}
	}
	{
		if s.Geometry.Set {
			e.FieldStart("geometry")
			s.Geometry.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfCanvas = [3]string{
	0: "winding",
	1: "geometry",
	2: "text",
}

// Decode decodes Canvas from json.
func (s *Canvas) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Canvas to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "winding":
			if err := func() error {
				s.Winding.Reset()
				if err := s.Winding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winding\"")
			}
		case "geometry":
			if err := func() error {
				s.Geometry.Reset()
				if err := s.Geometry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geometry\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Canvas")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Canvas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Canvas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientReferrer as json.
func (s ClientReferrer) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ClientReferrer from json.
func (s *ClientReferrer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientReferrer to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClientReferrer(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClientReferrer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientReferrer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClonedApp as json.
func (s ClonedApp) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes ClonedApp from json.
func (s *ClonedApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClonedApp to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClonedApp(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClonedApp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClonedApp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ColorDepth as json.
func (s ColorDepth) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes ColorDepth from json.
func (s *ColorDepth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColorDepth to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ColorDepth(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ColorDepth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColorDepth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CookiesEnabled as json.
func (s CookiesEnabled) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes CookiesEnabled from json.
func (s *CookiesEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CookiesEnabled to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CookiesEnabled(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CookiesEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CookiesEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeLocale as json.
func (s DateTimeLocale) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DateTimeLocale from json.
func (s *DateTimeLocale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DateTimeLocale to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DateTimeLocale(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DateTimeLocale) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DateTimeLocale) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVisitorDataBadRequest as json.
func (s *DeleteVisitorDataBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVisitorDataBadRequest from json.
func (s *DeleteVisitorDataBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVisitorDataBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVisitorDataBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVisitorDataBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVisitorDataBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVisitorDataForbidden as json.
func (s *DeleteVisitorDataForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVisitorDataForbidden from json.
func (s *DeleteVisitorDataForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVisitorDataForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVisitorDataForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVisitorDataForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVisitorDataForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVisitorDataNotFound as json.
func (s *DeleteVisitorDataNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVisitorDataNotFound from json.
func (s *DeleteVisitorDataNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVisitorDataNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVisitorDataNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVisitorDataNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVisitorDataNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVisitorDataTooManyRequests as json.
func (s *DeleteVisitorDataTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVisitorDataTooManyRequests from json.
func (s *DeleteVisitorDataTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVisitorDataTooManyRequests to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVisitorDataTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVisitorDataTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVisitorDataTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeveloperTools as json.
func (s DeveloperTools) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes DeveloperTools from json.
func (s *DeveloperTools) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeveloperTools to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeveloperTools(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeveloperTools) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeveloperTools) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeviceMemory as json.
func (s DeviceMemory) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes DeviceMemory from json.
func (s *DeviceMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeviceMemory to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeviceMemory(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeviceMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeviceMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Emoji) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Emoji) encodeFields(e *jx.Encoder) {
	{
		if s.Font.Set {
			e.FieldStart("font")
			s.Font.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Top.Set {
			e.FieldStart("top")
			s.Top.Encode(e)
		}
	}
	{
		if s.Bottom.Set {
			e.FieldStart("bottom")
			s.Bottom.Encode(e)
		}
	}
	{
		if s.Left.Set {
			e.FieldStart("left")
			s.Left.Encode(e)
		}
	}
	{
		if s.Right.Set {
			e.FieldStart("right")
			s.Right.Encode(e)
		}
	}
	{
		if s.X.Set {
			e.FieldStart("x")
			s.X.Encode(e)
		}
	}
	{
		if s.Y.Set {
			e.FieldStart("y")
			s.Y.Encode(e)
		}
	}
}

var jsonFieldsNameOfEmoji = [9]string{
	0: "font",
	1: "width",
	2: "height",
	3: "top",
	4: "bottom",
	5: "left",
	6: "right",
	7: "x",
	8: "y",
}

// Decode decodes Emoji from json.
func (s *Emoji) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Emoji to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "font":
			if err := func() error {
				s.Font.Reset()
				if err := s.Font.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"font\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "top":
			if err := func() error {
				s.Top.Reset()
				if err := s.Top.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top\"")
			}
		case "bottom":
			if err := func() error {
				s.Bottom.Reset()
				if err := s.Bottom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bottom\"")
			}
		case "left":
			if err := func() error {
				s.Left.Reset()
				if err := s.Left.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left\"")
			}
		case "right":
			if err := func() error {
				s.Right.Reset()
				if err := s.Right.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"right\"")
			}
		case "x":
			if err := func() error {
				s.X.Reset()
				if err := s.X.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			if err := func() error {
				s.Y.Reset()
				if err := s.Y.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Emoji")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Emoji) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Emoji) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Emulator as json.
func (s Emulator) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Emulator from json.
func (s *Emulator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Emulator to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Emulator(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Emulator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Emulator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentId as json.
func (s EnvironmentId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes EnvironmentId from json.
func (s *EnvironmentId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EnvironmentId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (s ErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ErrorCode from json.
func (s *ErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ErrorCode(v) {
	case ErrorCodeRequestCannotBeParsed:
		*s = ErrorCodeRequestCannotBeParsed
	case ErrorCodeSecretAPIKeyRequired:
		*s = ErrorCodeSecretAPIKeyRequired
	case ErrorCodeSecretAPIKeyNotFound:
		*s = ErrorCodeSecretAPIKeyNotFound
	case ErrorCodePublicAPIKeyRequired:
		*s = ErrorCodePublicAPIKeyRequired
	case ErrorCodePublicAPIKeyNotFound:
		*s = ErrorCodePublicAPIKeyNotFound
	case ErrorCodeSubscriptionNotActive:
		*s = ErrorCodeSubscriptionNotActive
	case ErrorCodeWrongRegion:
		*s = ErrorCodeWrongRegion
	case ErrorCodeFeatureNotEnabled:
		*s = ErrorCodeFeatureNotEnabled
	case ErrorCodeRequestNotFound:
		*s = ErrorCodeRequestNotFound
	case ErrorCodeVisitorNotFound:
		*s = ErrorCodeVisitorNotFound
	case ErrorCodeTooManyRequests:
		*s = ErrorCodeTooManyRequests
	case ErrorCodeStateNotReady:
		*s = ErrorCodeStateNotReady
	case ErrorCodeFailed:
		*s = ErrorCodeFailed
	case ErrorCodeEventNotFound:
		*s = ErrorCodeEventNotFound
	case ErrorCodeMissingModule:
		*s = ErrorCodeMissingModule
	case ErrorCodePayloadTooLarge:
		*s = ErrorCodePayloadTooLarge
	case ErrorCodeServiceUnavailable:
		*s = ErrorCodeServiceUnavailable
	case ErrorCodeRulesetNotFound:
		*s = ErrorCodeRulesetNotFound
	default:
		*s = ErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "error",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Event) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_id")
		s.EventID.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		s.Timestamp.Encode(e)
	}
	{
		if s.LinkedID.Set {
			e.FieldStart("linked_id")
			s.LinkedID.Encode(e)
		}
	}
	{
		if s.EnvironmentID.Set {
			e.FieldStart("environment_id")
			s.EnvironmentID.Encode(e)
		}
	}
	{
		if s.Suspect.Set {
			e.FieldStart("suspect")
			s.Suspect.Encode(e)
		}
	}
	{
		if s.Sdk.Set {
			e.FieldStart("sdk")
			s.Sdk.Encode(e)
		}
	}
	{
		if s.Replayed.Set {
			e.FieldStart("replayed")
			s.Replayed.Encode(e)
		}
	}
	{
		if s.Identification.Set {
			e.FieldStart("identification")
			s.Identification.Encode(e)
		}
	}
	{
		if s.SupplementaryIDHighRecall.Set {
			e.FieldStart("supplementary_id_high_recall")
			s.SupplementaryIDHighRecall.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.BundleID.Set {
			e.FieldStart("bundle_id")
			s.BundleID.Encode(e)
		}
	}
	{
		if s.PackageName.Set {
			e.FieldStart("package_name")
			s.PackageName.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.UserAgent.Set {
			e.FieldStart("user_agent")
			s.UserAgent.Encode(e)
		}
	}
	{
		if s.ClientReferrer.Set {
			e.FieldStart("client_referrer")
			s.ClientReferrer.Encode(e)
		}
	}
	{
		if s.BrowserDetails.Set {
			e.FieldStart("browser_details")
			s.BrowserDetails.Encode(e)
		}
	}
	{
		if s.Proximity.Set {
			e.FieldStart("proximity")
			s.Proximity.Encode(e)
		}
	}
	{
		if s.Bot.Set {
			e.FieldStart("bot")
			s.Bot.Encode(e)
		}
	}
	{
		if s.BotType.Set {
			e.FieldStart("bot_type")
			s.BotType.Encode(e)
		}
	}
	{
		if s.BotInfo.Set {
			e.FieldStart("bot_info")
			s.BotInfo.Encode(e)
		}
	}
	{
		if s.ClonedApp.Set {
			e.FieldStart("cloned_app")
			s.ClonedApp.Encode(e)
		}
	}
	{
		if s.DeveloperTools.Set {
			e.FieldStart("developer_tools")
			s.DeveloperTools.Encode(e)
		}
	}
	{
		if s.Emulator.Set {
			e.FieldStart("emulator")
			s.Emulator.Encode(e)
		}
	}
	{
		if s.FactoryResetTimestamp.Set {
			e.FieldStart("factory_reset_timestamp")
			s.FactoryResetTimestamp.Encode(e)
		}
	}
	{
		if s.Frida.Set {
			e.FieldStart("frida")
			s.Frida.Encode(e)
		}
	}
	{
		if s.IPBlocklist.Set {
			e.FieldStart("ip_blocklist")
			s.IPBlocklist.Encode(e)
		}
	}
	{
		if s.IPInfo.Set {
			e.FieldStart("ip_info")
			s.IPInfo.Encode(e)
		}
	}
	{
		if s.Proxy.Set {
			e.FieldStart("proxy")
			s.Proxy.Encode(e)
		}
	}
	{
		if s.ProxyConfidence.Set {
			e.FieldStart("proxy_confidence")
			s.ProxyConfidence.Encode(e)
		}
	}
	{
		if s.ProxyDetails.Set {
			e.FieldStart("proxy_details")
			s.ProxyDetails.Encode(e)
		}
	}
	{
		if s.Incognito.Set {
			e.FieldStart("incognito")
			s.Incognito.Encode(e)
		}
	}
	{
		if s.Jailbroken.Set {
			e.FieldStart("jailbroken")
			s.Jailbroken.Encode(e)
		}
	}
	{
		if s.LocationSpoofing.Set {
			e.FieldStart("location_spoofing")
			s.LocationSpoofing.Encode(e)
		}
	}
	{
		if s.MitmAttack.Set {
			e.FieldStart("mitm_attack")
			s.MitmAttack.Encode(e)
		}
	}
	{
		if s.PrivacySettings.Set {
			e.FieldStart("privacy_settings")
			s.PrivacySettings.Encode(e)
		}
	}
	{
		if s.RootApps.Set {
			e.FieldStart("root_apps")
			s.RootApps.Encode(e)
		}
	}
	{
		if s.RuleAction.Set {
			e.FieldStart("rule_action")
			s.RuleAction.Encode(e)
		}
	}
	{
		if s.SuspectScore.Set {
			e.FieldStart("suspect_score")
			s.SuspectScore.Encode(e)
		}
	}
	{
		if s.Tampering.Set {
			e.FieldStart("tampering")
			s.Tampering.Encode(e)
		}
	}
	{
		if s.TamperingDetails.Set {
			e.FieldStart("tampering_details")
			s.TamperingDetails.Encode(e)
		}
	}
	{
		if s.Velocity.Set {
			e.FieldStart("velocity")
			s.Velocity.Encode(e)
		}
	}
	{
		if s.VirtualMachine.Set {
			e.FieldStart("virtual_machine")
			s.VirtualMachine.Encode(e)
		}
	}
	{
		if s.Vpn.Set {
			e.FieldStart("vpn")
			s.Vpn.Encode(e)
		}
	}
	{
		if s.VpnConfidence.Set {
			e.FieldStart("vpn_confidence")
			s.VpnConfidence.Encode(e)
		}
	}
	{
		if s.VpnOriginTimezone.Set {
			e.FieldStart("vpn_origin_timezone")
			s.VpnOriginTimezone.Encode(e)
		}
	}
	{
		if s.VpnOriginCountry.Set {
			e.FieldStart("vpn_origin_country")
			s.VpnOriginCountry.Encode(e)
		}
	}
	{
		if s.VpnMethods.Set {
			e.FieldStart("vpn_methods")
			s.VpnMethods.Encode(e)
		}
	}
	{
		if s.HighActivityDevice.Set {
			e.FieldStart("high_activity_device")
			s.HighActivityDevice.Encode(e)
		}
	}
	{
		if s.RawDeviceAttributes.Set {
			e.FieldStart("raw_device_attributes")
			s.RawDeviceAttributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfEvent = [50]string{
	0:  "event_id",
	1:  "timestamp",
	2:  "linked_id",
	3:  "environment_id",
	4:  "suspect",
	5:  "sdk",
	6:  "replayed",
	7:  "identification",
	8:  "supplementary_id_high_recall",
	9:  "tags",
	10: "url",
	11: "bundle_id",
	12: "package_name",
	13: "ip_address",
	14: "user_agent",
	15: "client_referrer",
	16: "browser_details",
	17: "proximity",
	18: "bot",
	19: "bot_type",
	20: "bot_info",
	21: "cloned_app",
	22: "developer_tools",
	23: "emulator",
	24: "factory_reset_timestamp",
	25: "frida",
	26: "ip_blocklist",
	27: "ip_info",
	28: "proxy",
	29: "proxy_confidence",
	30: "proxy_details",
	31: "incognito",
	32: "jailbroken",
	33: "location_spoofing",
	34: "mitm_attack",
	35: "privacy_settings",
	36: "root_apps",
	37: "rule_action",
	38: "suspect_score",
	39: "tampering",
	40: "tampering_details",
	41: "velocity",
	42: "virtual_machine",
	43: "vpn",
	44: "vpn_confidence",
	45: "vpn_origin_timezone",
	46: "vpn_origin_country",
	47: "vpn_methods",
	48: "high_activity_device",
	49: "raw_device_attributes",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}
	var requiredBitSet [7]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "linked_id":
			if err := func() error {
				s.LinkedID.Reset()
				if err := s.LinkedID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linked_id\"")
			}
		case "environment_id":
			if err := func() error {
				s.EnvironmentID.Reset()
				if err := s.EnvironmentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_id\"")
			}
		case "suspect":
			if err := func() error {
				s.Suspect.Reset()
				if err := s.Suspect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspect\"")
			}
		case "sdk":
			if err := func() error {
				s.Sdk.Reset()
				if err := s.Sdk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sdk\"")
			}
		case "replayed":
			if err := func() error {
				s.Replayed.Reset()
				if err := s.Replayed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replayed\"")
			}
		case "identification":
			if err := func() error {
				s.Identification.Reset()
				if err := s.Identification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identification\"")
			}
		case "supplementary_id_high_recall":
			if err := func() error {
				s.SupplementaryIDHighRecall.Reset()
				if err := s.SupplementaryIDHighRecall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementary_id_high_recall\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = nil
				var elem Tags
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tags = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "bundle_id":
			if err := func() error {
				s.BundleID.Reset()
				if err := s.BundleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundle_id\"")
			}
		case "package_name":
			if err := func() error {
				s.PackageName.Reset()
				if err := s.PackageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_name\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "user_agent":
			if err := func() error {
				s.UserAgent.Reset()
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_agent\"")
			}
		case "client_referrer":
			if err := func() error {
				s.ClientReferrer.Reset()
				if err := s.ClientReferrer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_referrer\"")
			}
		case "browser_details":
			if err := func() error {
				s.BrowserDetails.Reset()
				if err := s.BrowserDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_details\"")
			}
		case "proximity":
			if err := func() error {
				s.Proximity.Reset()
				if err := s.Proximity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity\"")
			}
		case "bot":
			if err := func() error {
				s.Bot.Reset()
				if err := s.Bot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot\"")
			}
		case "bot_type":
			if err := func() error {
				s.BotType.Reset()
				if err := s.BotType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_type\"")
			}
		case "bot_info":
			if err := func() error {
				s.BotInfo.Reset()
				if err := s.BotInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_info\"")
			}
		case "cloned_app":
			if err := func() error {
				s.ClonedApp.Reset()
				if err := s.ClonedApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cloned_app\"")
			}
		case "developer_tools":
			if err := func() error {
				s.DeveloperTools.Reset()
				if err := s.DeveloperTools.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"developer_tools\"")
			}
		case "emulator":
			if err := func() error {
				s.Emulator.Reset()
				if err := s.Emulator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emulator\"")
			}
		case "factory_reset_timestamp":
			if err := func() error {
				s.FactoryResetTimestamp.Reset()
				if err := s.FactoryResetTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"factory_reset_timestamp\"")
			}
		case "frida":
			if err := func() error {
				s.Frida.Reset()
				if err := s.Frida.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frida\"")
			}
		case "ip_blocklist":
			if err := func() error {
				s.IPBlocklist.Reset()
				if err := s.IPBlocklist.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_blocklist\"")
			}
		case "ip_info":
			if err := func() error {
				s.IPInfo.Reset()
				if err := s.IPInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_info\"")
			}
		case "proxy":
			if err := func() error {
				s.Proxy.Reset()
				if err := s.Proxy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxy\"")
			}
		case "proxy_confidence":
			if err := func() error {
				s.ProxyConfidence.Reset()
				if err := s.ProxyConfidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxy_confidence\"")
			}
		case "proxy_details":
			if err := func() error {
				s.ProxyDetails.Reset()
				if err := s.ProxyDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxy_details\"")
			}
		case "incognito":
			if err := func() error {
				s.Incognito.Reset()
				if err := s.Incognito.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incognito\"")
			}
		case "jailbroken":
			if err := func() error {
				s.Jailbroken.Reset()
				if err := s.Jailbroken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jailbroken\"")
			}
		case "location_spoofing":
			if err := func() error {
				s.LocationSpoofing.Reset()
				if err := s.LocationSpoofing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location_spoofing\"")
			}
		case "mitm_attack":
			if err := func() error {
				s.MitmAttack.Reset()
				if err := s.MitmAttack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitm_attack\"")
			}
		case "privacy_settings":
			if err := func() error {
				s.PrivacySettings.Reset()
				if err := s.PrivacySettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy_settings\"")
			}
		case "root_apps":
			if err := func() error {
				s.RootApps.Reset()
				if err := s.RootApps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_apps\"")
			}
		case "rule_action":
			if err := func() error {
				s.RuleAction.Reset()
				if err := s.RuleAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_action\"")
			}
		case "suspect_score":
			if err := func() error {
				s.SuspectScore.Reset()
				if err := s.SuspectScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspect_score\"")
			}
		case "tampering":
			if err := func() error {
				s.Tampering.Reset()
				if err := s.Tampering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tampering\"")
			}
		case "tampering_details":
			if err := func() error {
				s.TamperingDetails.Reset()
				if err := s.TamperingDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tampering_details\"")
			}
		case "velocity":
			if err := func() error {
				s.Velocity.Reset()
				if err := s.Velocity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"velocity\"")
			}
		case "virtual_machine":
			if err := func() error {
				s.VirtualMachine.Reset()
				if err := s.VirtualMachine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtual_machine\"")
			}
		case "vpn":
			if err := func() error {
				s.Vpn.Reset()
				if err := s.Vpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn\"")
			}
		case "vpn_confidence":
			if err := func() error {
				s.VpnConfidence.Reset()
				if err := s.VpnConfidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn_confidence\"")
			}
		case "vpn_origin_timezone":
			if err := func() error {
				s.VpnOriginTimezone.Reset()
				if err := s.VpnOriginTimezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn_origin_timezone\"")
			}
		case "vpn_origin_country":
			if err := func() error {
				s.VpnOriginCountry.Reset()
				if err := s.VpnOriginCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn_origin_country\"")
			}
		case "vpn_methods":
			if err := func() error {
				s.VpnMethods.Reset()
				if err := s.VpnMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vpn_methods\"")
			}
		case "high_activity_device":
			if err := func() error {
				s.HighActivityDevice.Reset()
				if err := s.HighActivityDevice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"high_activity_device\"")
			}
		case "raw_device_attributes":
			if err := func() error {
				s.RawDeviceAttributes.Reset()
				if err := s.RawDeviceAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_device_attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [7]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvent) {
					name = jsonFieldsNameOfEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventId as json.
func (s EventId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes EventId from json.
func (s *EventId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EventId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRuleAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRuleAction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ruleset_id")
		s.RulesetID.Encode(e)
	}
	{
		if s.RuleID.Set {
			e.FieldStart("rule_id")
			s.RuleID.Encode(e)
		}
	}
	{
		if s.RuleExpression.Set {
			e.FieldStart("rule_expression")
			s.RuleExpression.Encode(e)
		}
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfEventRuleAction = [3]string{
	0: "ruleset_id",
	1: "rule_id",
	2: "rule_expression",
}

// Decode decodes EventRuleAction from json.
func (s *EventRuleAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRuleAction to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ruleset_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RulesetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ruleset_id\"")
			}
		case "rule_id":
			if err := func() error {
				s.RuleID.Reset()
				if err := s.RuleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_id\"")
			}
		case "rule_expression":
			if err := func() error {
				s.RuleExpression.Reset()
				if err := s.RuleExpression.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_expression\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRuleAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRuleAction) {
					name = jsonFieldsNameOfEventRuleAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRuleActionAllow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRuleActionAllow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.RequestHeaderModifications.Set {
			e.FieldStart("request_header_modifications")
			s.RequestHeaderModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventRuleActionAllow = [2]string{
	0: "type",
	1: "request_header_modifications",
}

// Decode decodes EventRuleActionAllow from json.
func (s *EventRuleActionAllow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRuleActionAllow to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "request_header_modifications":
			if err := func() error {
				s.RequestHeaderModifications.Reset()
				if err := s.RequestHeaderModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_header_modifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRuleActionAllow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRuleActionAllow) {
					name = jsonFieldsNameOfEventRuleActionAllow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRuleActionAllow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRuleActionAllow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRuleActionBlock) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRuleActionBlock) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("status_code")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventRuleActionBlock = [4]string{
	0: "type",
	1: "status_code",
	2: "headers",
	3: "body",
}

// Decode decodes EventRuleActionBlock from json.
func (s *EventRuleActionBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRuleActionBlock to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status_code":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = make([]RuleActionHeaderField, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleActionHeaderField
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRuleActionBlock")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRuleActionBlock) {
					name = jsonFieldsNameOfEventRuleActionBlock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRuleActionBlock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRuleActionBlock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRuleActionSum as json.
func (s EventRuleActionSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s EventRuleActionSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case EventRuleActionAllowEventRuleActionSum:
		e.FieldStart("type")
		e.Str("allow")
		{
			s := s.EventRuleActionAllow
			{
				if s.RequestHeaderModifications.Set {
					e.FieldStart("request_header_modifications")
					s.RequestHeaderModifications.Encode(e)
				}
			}
		}
	case EventRuleActionBlockEventRuleActionSum:
		e.FieldStart("type")
		e.Str("block")
		{
			s := s.EventRuleActionBlock
			{
				if s.StatusCode.Set {
					e.FieldStart("status_code")
					s.StatusCode.Encode(e)
				}
			}
			{
				if s.Headers != nil {
					e.FieldStart("headers")
					e.ArrStart()
					for _, elem := range s.Headers {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Body.Set {
					e.FieldStart("body")
					s.Body.Encode(e)
				}
			}
		}
	}
}

// Decode decodes EventRuleActionSum from json.
func (s *EventRuleActionSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRuleActionSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "allow":
					s.Type = EventRuleActionAllowEventRuleActionSum
					found = true
				case "block":
					s.Type = EventRuleActionBlockEventRuleActionSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case EventRuleActionAllowEventRuleActionSum:
		if err := s.EventRuleActionAllow.Decode(d); err != nil {
			return err
		}
	case EventRuleActionBlockEventRuleActionSum:
		if err := s.EventRuleActionBlock.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventRuleActionSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRuleActionSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventSearch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventSearch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.PaginationKey.Set {
			e.FieldStart("pagination_key")
			s.PaginationKey.Encode(e)
		}
	}
	{
		if s.TotalHits.Set {
			e.FieldStart("total_hits")
			s.TotalHits.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventSearch = [3]string{
	0: "events",
	1: "pagination_key",
	2: "total_hits",
}

// Decode decodes EventSearch from json.
func (s *EventSearch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSearch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Events = make([]Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "pagination_key":
			if err := func() error {
				s.PaginationKey.Reset()
				if err := s.PaginationKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination_key\"")
			}
		case "total_hits":
			if err := func() error {
				s.TotalHits.Reset()
				if err := s.TotalHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_hits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventSearch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventSearch) {
					name = jsonFieldsNameOfEventSearch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventSearch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSearch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.LinkedID.Set {
			e.FieldStart("linked_id")
			s.LinkedID.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Suspect.Set {
			e.FieldStart("suspect")
			s.Suspect.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventUpdate = [3]string{
	0: "linked_id",
	1: "tags",
	2: "suspect",
}

// Decode decodes EventUpdate from json.
func (s *EventUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "linked_id":
			if err := func() error {
				s.LinkedID.Reset()
				if err := s.LinkedID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linked_id\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = nil
				var elem EventUpdateTags
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tags = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "suspect":
			if err := func() error {
				s.Suspect.Reset()
				if err := s.Suspect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspect\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventUpdateTags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventUpdateTags) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventUpdateTags = [0]string{}

// Decode decodes EventUpdateTags from json.
func (s *EventUpdateTags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventUpdateTags to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EventUpdateTags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventUpdateTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventUpdateTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactoryReset as json.
func (s FactoryReset) Encode(e *jx.Encoder) {
	unwrapped := int64(s)

	e.Int64(unwrapped)
}

// Decode decodes FactoryReset from json.
func (s *FactoryReset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactoryReset to nil")
	}
	var unwrapped int64
	if err := func() error {
		v, err := d.Int64()
		unwrapped = int64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FactoryReset(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactoryReset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactoryReset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FontPreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FontPreferences) encodeFields(e *jx.Encoder) {
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.Serif.Set {
			e.FieldStart("serif")
			s.Serif.Encode(e)
		}
	}
	{
		if s.Sans.Set {
			e.FieldStart("sans")
			s.Sans.Encode(e)
		}
	}
	{
		if s.Mono.Set {
			e.FieldStart("mono")
			s.Mono.Encode(e)
		}
	}
	{
		if s.Apple.Set {
			e.FieldStart("apple")
			s.Apple.Encode(e)
		}
	}
	{
		if s.Min.Set {
			e.FieldStart("min")
			s.Min.Encode(e)
		}
	}
	{
		if s.System.Set {
			e.FieldStart("system")
			s.System.Encode(e)
		}
	}
}

var jsonFieldsNameOfFontPreferences = [7]string{
	0: "default",
	1: "serif",
	2: "sans",
	3: "mono",
	4: "apple",
	5: "min",
	6: "system",
}

// Decode decodes FontPreferences from json.
func (s *FontPreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FontPreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "serif":
			if err := func() error {
				s.Serif.Reset()
				if err := s.Serif.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serif\"")
			}
		case "sans":
			if err := func() error {
				s.Sans.Reset()
				if err := s.Sans.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sans\"")
			}
		case "mono":
			if err := func() error {
				s.Mono.Reset()
				if err := s.Mono.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mono\"")
			}
		case "apple":
			if err := func() error {
				s.Apple.Reset()
				if err := s.Apple.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apple\"")
			}
		case "min":
			if err := func() error {
				s.Min.Reset()
				if err := s.Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		case "system":
			if err := func() error {
				s.System.Reset()
				if err := s.System.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FontPreferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FontPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FontPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Fonts as json.
func (s Fonts) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes Fonts from json.
func (s *Fonts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Fonts to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Fonts(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Fonts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Fonts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Frida as json.
func (s Frida) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Frida from json.
func (s *Frida) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Frida to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Frida(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Frida) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Frida) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Geolocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Geolocation) encodeFields(e *jx.Encoder) {
	{
		if s.AccuracyRadius.Set {
			e.FieldStart("accuracy_radius")
			s.AccuracyRadius.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.PostalCode.Set {
			e.FieldStart("postal_code")
			s.PostalCode.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.CityName.Set {
			e.FieldStart("city_name")
			s.CityName.Encode(e)
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("country_code")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.CountryName.Set {
			e.FieldStart("country_name")
			s.CountryName.Encode(e)
		}
	}
	{
		if s.ContinentCode.Set {
			e.FieldStart("continent_code")
			s.ContinentCode.Encode(e)
		}
	}
	{
		if s.ContinentName.Set {
			e.FieldStart("continent_name")
			s.ContinentName.Encode(e)
		}
	}
	{
		if s.Subdivisions != nil {
			e.FieldStart("subdivisions")
			e.ArrStart()
			for _, elem := range s.Subdivisions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGeolocation = [11]string{
	0:  "accuracy_radius",
	1:  "latitude",
	2:  "longitude",
	3:  "postal_code",
	4:  "timezone",
	5:  "city_name",
	6:  "country_code",
	7:  "country_name",
	8:  "continent_code",
	9:  "continent_name",
	10: "subdivisions",
}

// Decode decodes Geolocation from json.
func (s *Geolocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Geolocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accuracy_radius":
			if err := func() error {
				s.AccuracyRadius.Reset()
				if err := s.AccuracyRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accuracy_radius\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "postal_code":
			if err := func() error {
				s.PostalCode.Reset()
				if err := s.PostalCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postal_code\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "city_name":
			if err := func() error {
				s.CityName.Reset()
				if err := s.CityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city_name\"")
			}
		case "country_code":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_code\"")
			}
		case "country_name":
			if err := func() error {
				s.CountryName.Reset()
				if err := s.CountryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_name\"")
			}
		case "continent_code":
			if err := func() error {
				s.ContinentCode.Reset()
				if err := s.ContinentCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent_code\"")
			}
		case "continent_name":
			if err := func() error {
				s.ContinentName.Reset()
				if err := s.ContinentName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continent_name\"")
			}
		case "subdivisions":
			if err := func() error {
				s.Subdivisions = make([]GeolocationSubdivisionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GeolocationSubdivisionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subdivisions = append(s.Subdivisions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdivisions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Geolocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Geolocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Geolocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeolocationSubdivisionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeolocationSubdivisionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("iso_code")
		e.Str(s.IsoCode)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGeolocationSubdivisionsItem = [2]string{
	0: "iso_code",
	1: "name",
}

// Decode decodes GeolocationSubdivisionsItem from json.
func (s *GeolocationSubdivisionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeolocationSubdivisionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "iso_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IsoCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iso_code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeolocationSubdivisionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeolocationSubdivisionsItem) {
					name = jsonFieldsNameOfGeolocationSubdivisionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeolocationSubdivisionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeolocationSubdivisionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventBadRequest as json.
func (s *GetEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventBadRequest from json.
func (s *GetEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventForbidden as json.
func (s *GetEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventForbidden from json.
func (s *GetEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventInternalServerError as json.
func (s *GetEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventInternalServerError from json.
func (s *GetEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventNotFound as json.
func (s *GetEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventNotFound from json.
func (s *GetEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventTooManyRequests as json.
func (s *GetEventTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventTooManyRequests from json.
func (s *GetEventTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventTooManyRequests to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HardwareConcurrency as json.
func (s HardwareConcurrency) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes HardwareConcurrency from json.
func (s *HardwareConcurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareConcurrency to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HardwareConcurrency(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HardwareConcurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareConcurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HighActivity as json.
func (s HighActivity) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes HighActivity from json.
func (s *HighActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HighActivity to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HighActivity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HighActivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HighActivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IPBlockList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IPBlockList) encodeFields(e *jx.Encoder) {
	{
		if s.EmailSpam.Set {
			e.FieldStart("email_spam")
			s.EmailSpam.Encode(e)
		}
	}
	{
		if s.AttackSource.Set {
			e.FieldStart("attack_source")
			s.AttackSource.Encode(e)
		}
	}
	{
		if s.TorNode.Set {
			e.FieldStart("tor_node")
			s.TorNode.Encode(e)
		}
	}
}

var jsonFieldsNameOfIPBlockList = [3]string{
	0: "email_spam",
	1: "attack_source",
	2: "tor_node",
}

// Decode decodes IPBlockList from json.
func (s *IPBlockList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IPBlockList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email_spam":
			if err := func() error {
				s.EmailSpam.Reset()
				if err := s.EmailSpam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_spam\"")
			}
		case "attack_source":
			if err := func() error {
				s.AttackSource.Reset()
				if err := s.AttackSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_source\"")
			}
		case "tor_node":
			if err := func() error {
				s.TorNode.Reset()
				if err := s.TorNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tor_node\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IPBlockList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IPBlockList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IPBlockList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IPInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IPInfo) encodeFields(e *jx.Encoder) {
	{
		if s.V4.Set {
			e.FieldStart("v4")
			s.V4.Encode(e)
		}
	}
	{
		if s.V6.Set {
			e.FieldStart("v6")
			s.V6.Encode(e)
		}
	}
}

var jsonFieldsNameOfIPInfo = [2]string{
	0: "v4",
	1: "v6",
}

// Decode decodes IPInfo from json.
func (s *IPInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IPInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "v4":
			if err := func() error {
				s.V4.Reset()
				if err := s.V4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"v4\"")
			}
		case "v6":
			if err := func() error {
				s.V6.Reset()
				if err := s.V6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"v6\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IPInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IPInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IPInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IPInfoV4) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IPInfoV4) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("address")
		json.EncodeIPv4(e, s.Address)
	}
	{
		if s.Geolocation.Set {
			e.FieldStart("geolocation")
			s.Geolocation.Encode(e)
		}
	}
	{
		if s.Asn.Set {
			e.FieldStart("asn")
			s.Asn.Encode(e)
		}
	}
	{
		if s.AsnName.Set {
			e.FieldStart("asn_name")
			s.AsnName.Encode(e)
		}
	}
	{
		if s.AsnNetwork.Set {
			e.FieldStart("asn_network")
			s.AsnNetwork.Encode(e)
		}
	}
	{
		if s.AsnType.Set {
			e.FieldStart("asn_type")
			s.AsnType.Encode(e)
		}
	}
	{
		if s.DatacenterResult.Set {
			e.FieldStart("datacenter_result")
			s.DatacenterResult.Encode(e)
		}
	}
	{
		if s.DatacenterName.Set {
			e.FieldStart("datacenter_name")
			s.DatacenterName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIPInfoV4 = [8]string{
	0: "address",
	1: "geolocation",
	2: "asn",
	3: "asn_name",
	4: "asn_network",
	5: "asn_type",
	6: "datacenter_result",
	7: "datacenter_name",
}

// Decode decodes IPInfoV4 from json.
func (s *IPInfoV4) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IPInfoV4 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv4(d)
				s.Address = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "geolocation":
			if err := func() error {
				s.Geolocation.Reset()
				if err := s.Geolocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geolocation\"")
			}
		case "asn":
			if err := func() error {
				s.Asn.Reset()
				if err := s.Asn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn\"")
			}
		case "asn_name":
			if err := func() error {
				s.AsnName.Reset()
				if err := s.AsnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_name\"")
			}
		case "asn_network":
			if err := func() error {
				s.AsnNetwork.Reset()
				if err := s.AsnNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_network\"")
			}
		case "asn_type":
			if err := func() error {
				s.AsnType.Reset()
				if err := s.AsnType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_type\"")
			}
		case "datacenter_result":
			if err := func() error {
				s.DatacenterResult.Reset()
				if err := s.DatacenterResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenter_result\"")
			}
		case "datacenter_name":
			if err := func() error {
				s.DatacenterName.Reset()
				if err := s.DatacenterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenter_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IPInfoV4")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIPInfoV4) {
					name = jsonFieldsNameOfIPInfoV4[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IPInfoV4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IPInfoV4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IPInfoV6) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IPInfoV6) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("address")
		json.EncodeIPv6(e, s.Address)
	}
	{
		if s.Geolocation.Set {
			e.FieldStart("geolocation")
			s.Geolocation.Encode(e)
		}
	}
	{
		if s.Asn.Set {
			e.FieldStart("asn")
			s.Asn.Encode(e)
		}
	}
	{
		if s.AsnName.Set {
			e.FieldStart("asn_name")
			s.AsnName.Encode(e)
		}
	}
	{
		if s.AsnNetwork.Set {
			e.FieldStart("asn_network")
			s.AsnNetwork.Encode(e)
		}
	}
	{
		if s.AsnType.Set {
			e.FieldStart("asn_type")
			s.AsnType.Encode(e)
		}
	}
	{
		if s.DatacenterResult.Set {
			e.FieldStart("datacenter_result")
			s.DatacenterResult.Encode(e)
		}
	}
	{
		if s.DatacenterName.Set {
			e.FieldStart("datacenter_name")
			s.DatacenterName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIPInfoV6 = [8]string{
	0: "address",
	1: "geolocation",
	2: "asn",
	3: "asn_name",
	4: "asn_network",
	5: "asn_type",
	6: "datacenter_result",
	7: "datacenter_name",
}

// Decode decodes IPInfoV6 from json.
func (s *IPInfoV6) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IPInfoV6 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeIPv6(d)
				s.Address = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "geolocation":
			if err := func() error {
				s.Geolocation.Reset()
				if err := s.Geolocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geolocation\"")
			}
		case "asn":
			if err := func() error {
				s.Asn.Reset()
				if err := s.Asn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn\"")
			}
		case "asn_name":
			if err := func() error {
				s.AsnName.Reset()
				if err := s.AsnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_name\"")
			}
		case "asn_network":
			if err := func() error {
				s.AsnNetwork.Reset()
				if err := s.AsnNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_network\"")
			}
		case "asn_type":
			if err := func() error {
				s.AsnType.Reset()
				if err := s.AsnType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn_type\"")
			}
		case "datacenter_result":
			if err := func() error {
				s.DatacenterResult.Reset()
				if err := s.DatacenterResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenter_result\"")
			}
		case "datacenter_name":
			if err := func() error {
				s.DatacenterName.Reset()
				if err := s.DatacenterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenter_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IPInfoV6")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIPInfoV6) {
					name = jsonFieldsNameOfIPInfoV6[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IPInfoV6) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IPInfoV6) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Identification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Identification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("visitor_id")
		e.Str(s.VisitorID)
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
	{
		e.FieldStart("visitor_found")
		e.Bool(s.VisitorFound)
	}
	{
		if s.FirstSeenAt.Set {
			e.FieldStart("first_seen_at")
			s.FirstSeenAt.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfIdentification = [5]string{
	0: "visitor_id",
	1: "confidence",
	2: "visitor_found",
	3: "first_seen_at",
	4: "last_seen_at",
}

// Decode decodes Identification from json.
func (s *Identification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Identification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visitor_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VisitorID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visitor_id\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "visitor_found":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.VisitorFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visitor_found\"")
			}
		case "first_seen_at":
			if err := func() error {
				s.FirstSeenAt.Reset()
				if err := s.FirstSeenAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_seen_at\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Identification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIdentification) {
					name = jsonFieldsNameOfIdentification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Identification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Identification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IdentificationConfidence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IdentificationConfidence) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
}

var jsonFieldsNameOfIdentificationConfidence = [3]string{
	0: "score",
	1: "version",
	2: "comment",
}

// Decode decodes IdentificationConfidence from json.
func (s *IdentificationConfidence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentificationConfidence to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "score":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IdentificationConfidence")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIdentificationConfidence) {
					name = jsonFieldsNameOfIdentificationConfidence[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IdentificationConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentificationConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Incognito as json.
func (s Incognito) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Incognito from json.
func (s *Incognito) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Incognito to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Incognito(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Incognito) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Incognito) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndexedDb as json.
func (s IndexedDb) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IndexedDb from json.
func (s *IndexedDb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IndexedDb to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IndexedDb(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IndexedDb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IndexedDb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Integration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Integration) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Subintegration.Set {
			e.FieldStart("subintegration")
			s.Subintegration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntegration = [3]string{
	0: "name",
	1: "version",
	2: "subintegration",
}

// Decode decodes Integration from json.
func (s *Integration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Integration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "subintegration":
			if err := func() error {
				s.Subintegration.Reset()
				if err := s.Subintegration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subintegration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Integration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Integration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Integration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntegrationSubintegration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntegrationSubintegration) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntegrationSubintegration = [2]string{
	0: "name",
	1: "version",
}

// Decode decodes IntegrationSubintegration from json.
func (s *IntegrationSubintegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntegrationSubintegration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntegrationSubintegration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntegrationSubintegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntegrationSubintegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpAddress as json.
func (s IpAddress) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes IpAddress from json.
func (s *IpAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAddress to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IpAddress(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IpAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Jailbroken as json.
func (s Jailbroken) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Jailbroken from json.
func (s *Jailbroken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Jailbroken to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Jailbroken(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Jailbroken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Jailbroken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Languages as json.
func (s Languages) Encode(e *jx.Encoder) {
	unwrapped := [][]string(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			e.ArrStart()
			for _, elem := range elem {
				e.Str(elem)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
}

// Decode decodes Languages from json.
func (s *Languages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Languages to nil")
	}
	var unwrapped [][]string
	if err := func() error {
		unwrapped = make([][]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem []string
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Languages(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Languages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Languages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkedId as json.
func (s LinkedId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LinkedId from json.
func (s *LinkedId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkedId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LinkedId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LinkedId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkedId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalStorage as json.
func (s LocalStorage) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes LocalStorage from json.
func (s *LocalStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalStorage to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LocalStorage(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocalStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocationSpoofing as json.
func (s LocationSpoofing) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes LocationSpoofing from json.
func (s *LocationSpoofing) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocationSpoofing to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LocationSpoofing(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LocationSpoofing) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocationSpoofing) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Math as json.
func (s Math) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Math from json.
func (s *Math) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Math to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Math(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Math) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Math) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MitMAttack as json.
func (s MitMAttack) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes MitMAttack from json.
func (s *MitMAttack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MitMAttack to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MitMAttack(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MitMAttack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MitMAttack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Architecture as json.
func (o OptArchitecture) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Architecture from json.
func (o *OptArchitecture) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptArchitecture to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptArchitecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptArchitecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Audio as json.
func (o OptAudio) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Audio from json.
func (o *OptAudio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAudio to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotInfo as json.
func (o OptBotInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BotInfo from json.
func (o *OptBotInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBotInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBotInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBotInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotResult as json.
func (o OptBotResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BotResult from json.
func (o *OptBotResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBotResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBotResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBotResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotType as json.
func (o OptBotType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BotType from json.
func (o *OptBotType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBotType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBotType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBotType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BrowserDetails as json.
func (o OptBrowserDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BrowserDetails from json.
func (o *OptBrowserDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBrowserDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBrowserDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBrowserDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BundleId as json.
func (o OptBundleId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BundleId from json.
func (o *OptBundleId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBundleId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBundleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBundleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Canvas as json.
func (o OptCanvas) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Canvas from json.
func (o *OptCanvas) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCanvas to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCanvas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCanvas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientReferrer as json.
func (o OptClientReferrer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientReferrer from json.
func (o *OptClientReferrer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientReferrer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientReferrer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientReferrer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClonedApp as json.
func (o OptClonedApp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClonedApp from json.
func (o *OptClonedApp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClonedApp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClonedApp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClonedApp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ColorDepth as json.
func (o OptColorDepth) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ColorDepth from json.
func (o *OptColorDepth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptColorDepth to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptColorDepth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptColorDepth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CookiesEnabled as json.
func (o OptCookiesEnabled) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CookiesEnabled from json.
func (o *OptCookiesEnabled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCookiesEnabled to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCookiesEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCookiesEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeLocale as json.
func (o OptDateTimeLocale) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DateTimeLocale from json.
func (o *OptDateTimeLocale) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTimeLocale to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTimeLocale) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTimeLocale) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeveloperTools as json.
func (o OptDeveloperTools) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeveloperTools from json.
func (o *OptDeveloperTools) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeveloperTools to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeveloperTools) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeveloperTools) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeviceMemory as json.
func (o OptDeviceMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeviceMemory from json.
func (o *OptDeviceMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeviceMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeviceMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeviceMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Emoji as json.
func (o OptEmoji) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Emoji from json.
func (o *OptEmoji) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmoji to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmoji) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmoji) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Emulator as json.
func (o OptEmulator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Emulator from json.
func (o *OptEmulator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmulator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmulator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmulator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentId as json.
func (o OptEnvironmentId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnvironmentId from json.
func (o *OptEnvironmentId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnvironmentId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnvironmentId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnvironmentId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventRuleAction as json.
func (o OptEventRuleAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventRuleAction from json.
func (o *OptEventRuleAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventRuleAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactoryReset as json.
func (o OptFactoryReset) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FactoryReset from json.
func (o *OptFactoryReset) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFactoryReset to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFactoryReset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFactoryReset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FontPreferences as json.
func (o OptFontPreferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FontPreferences from json.
func (o *OptFontPreferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFontPreferences to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFontPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFontPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Frida as json.
func (o OptFrida) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Frida from json.
func (o *OptFrida) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFrida to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFrida) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFrida) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Geolocation as json.
func (o OptGeolocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Geolocation from json.
func (o *OptGeolocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGeolocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGeolocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGeolocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HardwareConcurrency as json.
func (o OptHardwareConcurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HardwareConcurrency from json.
func (o *OptHardwareConcurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHardwareConcurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHardwareConcurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHardwareConcurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HighActivity as json.
func (o OptHighActivity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HighActivity from json.
func (o *OptHighActivity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHighActivity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHighActivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHighActivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IPBlockList as json.
func (o OptIPBlockList) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IPBlockList from json.
func (o *OptIPBlockList) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPBlockList to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPBlockList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPBlockList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IPInfo as json.
func (o OptIPInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IPInfo from json.
func (o *OptIPInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IPInfoV4 as json.
func (o OptIPInfoV4) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IPInfoV4 from json.
func (o *OptIPInfoV4) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPInfoV4 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPInfoV4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPInfoV4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IPInfoV6 as json.
func (o OptIPInfoV6) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IPInfoV6 from json.
func (o *OptIPInfoV6) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPInfoV6 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPInfoV6) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPInfoV6) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Identification as json.
func (o OptIdentification) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Identification from json.
func (o *OptIdentification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIdentification to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIdentification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIdentification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IdentificationConfidence as json.
func (o OptIdentificationConfidence) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IdentificationConfidence from json.
func (o *OptIdentificationConfidence) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIdentificationConfidence to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIdentificationConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIdentificationConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Incognito as json.
func (o OptIncognito) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Incognito from json.
func (o *OptIncognito) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIncognito to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIncognito) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIncognito) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IndexedDb as json.
func (o OptIndexedDb) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IndexedDb from json.
func (o *OptIndexedDb) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIndexedDb to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIndexedDb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIndexedDb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntegrationSubintegration as json.
func (o OptIntegrationSubintegration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IntegrationSubintegration from json.
func (o *OptIntegrationSubintegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIntegrationSubintegration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIntegrationSubintegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIntegrationSubintegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpAddress as json.
func (o OptIpAddress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IpAddress from json.
func (o *OptIpAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIpAddress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIpAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIpAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Jailbroken as json.
func (o OptJailbroken) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Jailbroken from json.
func (o *OptJailbroken) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJailbroken to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJailbroken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJailbroken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkedId as json.
func (o OptLinkedId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinkedId from json.
func (o *OptLinkedId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinkedId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinkedId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinkedId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocalStorage as json.
func (o OptLocalStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LocalStorage from json.
func (o *OptLocalStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLocalStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLocalStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLocalStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocationSpoofing as json.
func (o OptLocationSpoofing) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LocationSpoofing from json.
func (o *OptLocationSpoofing) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLocationSpoofing to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLocationSpoofing) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLocationSpoofing) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Math as json.
func (o OptMath) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Math from json.
func (o *OptMath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMath to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MitMAttack as json.
func (o OptMitMAttack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MitMAttack from json.
func (o *OptMitMAttack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMitMAttack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMitMAttack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMitMAttack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Oscpu as json.
func (o OptOscpu) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Oscpu from json.
func (o *OptOscpu) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOscpu to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOscpu) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOscpu) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageName as json.
func (o OptPackageName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageName from json.
func (o *OptPackageName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPackageName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPackageName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Platform as json.
func (o OptPlatform) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Platform from json.
func (o *OptPlatform) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlatform to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlatform) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlatform) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PrivacySettings as json.
func (o OptPrivacySettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PrivacySettings from json.
func (o *OptPrivacySettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPrivacySettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPrivacySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPrivacySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Proximity as json.
func (o OptProximity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Proximity from json.
func (o *OptProximity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProximity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProximity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProximity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Proxy as json.
func (o OptProxy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Proxy from json.
func (o *OptProxy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyConfidence as json.
func (o OptProxyConfidence) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProxyConfidence from json.
func (o *OptProxyConfidence) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyConfidence to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyDetails as json.
func (o OptProxyDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProxyDetails from json.
func (o *OptProxyDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RawDeviceAttributes as json.
func (o OptRawDeviceAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RawDeviceAttributes from json.
func (o *OptRawDeviceAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRawDeviceAttributes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRawDeviceAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRawDeviceAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Replayed as json.
func (o OptReplayed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Replayed from json.
func (o *OptReplayed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReplayed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReplayed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReplayed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaderModifications as json.
func (o OptRequestHeaderModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestHeaderModifications from json.
func (o *OptRequestHeaderModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestHeaderModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestHeaderModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestHeaderModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootApps as json.
func (o OptRootApps) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RootApps from json.
func (o *OptRootApps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRootApps to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRootApps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRootApps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleActionBody as json.
func (o OptRuleActionBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RuleActionBody from json.
func (o *OptRuleActionBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleActionBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleActionBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleActionBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleExpression as json.
func (o OptRuleExpression) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RuleExpression from json.
func (o *OptRuleExpression) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleExpression to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleExpression) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleExpression) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleId as json.
func (o OptRuleId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RuleId from json.
func (o *OptRuleId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SDK as json.
func (o OptSDK) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SDK from json.
func (o *OptSDK) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSDK to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSDK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSDK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionStorage as json.
func (o OptSessionStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionStorage from json.
func (o *OptSessionStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StatusCode as json.
func (o OptStatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StatusCode from json.
func (o *OptStatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupplementaryIDHighRecall as json.
func (o OptSupplementaryIDHighRecall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupplementaryIDHighRecall from json.
func (o *OptSupplementaryIDHighRecall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupplementaryIDHighRecall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupplementaryIDHighRecall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupplementaryIDHighRecall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Suspect as json.
func (o OptSuspect) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Suspect from json.
func (o *OptSuspect) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuspect to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuspect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuspect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuspectScore as json.
func (o OptSuspectScore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuspectScore from json.
func (o *OptSuspectScore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuspectScore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuspectScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuspectScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tampering as json.
func (o OptTampering) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Tampering from json.
func (o *OptTampering) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTampering to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTampering) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTampering) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TamperingDetails as json.
func (o OptTamperingDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TamperingDetails from json.
func (o *OptTamperingDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTamperingDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTamperingDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTamperingDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Timezone as json.
func (o OptTimezone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Timezone from json.
func (o *OptTimezone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTimezone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTimezone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTimezone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TouchSupport as json.
func (o OptTouchSupport) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TouchSupport from json.
func (o *OptTouchSupport) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTouchSupport to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTouchSupport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTouchSupport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes URL as json.
func (o OptURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes URL from json.
func (o *OptURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAgent as json.
func (o OptUserAgent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAgent from json.
func (o *OptUserAgent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAgent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAgent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAgent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Velocity as json.
func (o OptVelocity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Velocity from json.
func (o *OptVelocity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVelocity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVelocity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVelocity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VelocityData as json.
func (o OptVelocityData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VelocityData from json.
func (o *OptVelocityData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVelocityData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVelocityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVelocityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Vendor as json.
func (o OptVendor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Vendor from json.
func (o *OptVendor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVendor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVendor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVendor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VirtualMachine as json.
func (o OptVirtualMachine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VirtualMachine from json.
func (o *OptVirtualMachine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVirtualMachine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVirtualMachine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVirtualMachine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Vpn as json.
func (o OptVpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Vpn from json.
func (o *OptVpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVpn to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnConfidence as json.
func (o OptVpnConfidence) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VpnConfidence from json.
func (o *OptVpnConfidence) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVpnConfidence to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVpnConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVpnConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnMethods as json.
func (o OptVpnMethods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VpnMethods from json.
func (o *OptVpnMethods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVpnMethods to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVpnMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVpnMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnOriginCountry as json.
func (o OptVpnOriginCountry) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VpnOriginCountry from json.
func (o *OptVpnOriginCountry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVpnOriginCountry to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVpnOriginCountry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVpnOriginCountry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnOriginTimezone as json.
func (o OptVpnOriginTimezone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VpnOriginTimezone from json.
func (o *OptVpnOriginTimezone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVpnOriginTimezone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVpnOriginTimezone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVpnOriginTimezone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebGlBasics as json.
func (o OptWebGlBasics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebGlBasics from json.
func (o *OptWebGlBasics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebGlBasics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebGlBasics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebGlBasics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebGlExtensions as json.
func (o OptWebGlExtensions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebGlExtensions from json.
func (o *OptWebGlExtensions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebGlExtensions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebGlExtensions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebGlExtensions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Oscpu as json.
func (s Oscpu) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Oscpu from json.
func (s *Oscpu) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Oscpu to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Oscpu(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Oscpu) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Oscpu) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageName as json.
func (s PackageName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PackageName from json.
func (s *PackageName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackageName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackageName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Platform as json.
func (s Platform) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Platform from json.
func (s *Platform) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Platform to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Platform(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Platform) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Platform) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Plugins as json.
func (s Plugins) Encode(e *jx.Encoder) {
	unwrapped := []PluginsItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes Plugins from json.
func (s *Plugins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Plugins to nil")
	}
	var unwrapped []PluginsItem
	if err := func() error {
		unwrapped = make([]PluginsItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PluginsItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Plugins(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Plugins) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Plugins) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PluginsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PluginsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.MimeTypes != nil {
			e.FieldStart("mimeTypes")
			e.ArrStart()
			for _, elem := range s.MimeTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPluginsItem = [3]string{
	0: "name",
	1: "description",
	2: "mimeTypes",
}

// Decode decodes PluginsItem from json.
func (s *PluginsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PluginsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "mimeTypes":
			if err := func() error {
				s.MimeTypes = make([]PluginsItemMimeTypesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PluginsItemMimeTypesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MimeTypes = append(s.MimeTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mimeTypes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PluginsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPluginsItem) {
					name = jsonFieldsNameOfPluginsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PluginsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PluginsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PluginsItemMimeTypesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PluginsItemMimeTypesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Suffixes.Set {
			e.FieldStart("suffixes")
			s.Suffixes.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfPluginsItemMimeTypesItem = [3]string{
	0: "type",
	1: "suffixes",
	2: "description",
}

// Decode decodes PluginsItemMimeTypesItem from json.
func (s *PluginsItemMimeTypesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PluginsItemMimeTypesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "suffixes":
			if err := func() error {
				s.Suffixes.Reset()
				if err := s.Suffixes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suffixes\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PluginsItemMimeTypesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PluginsItemMimeTypesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PluginsItemMimeTypesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PrivacySettings as json.
func (s PrivacySettings) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes PrivacySettings from json.
func (s *PrivacySettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivacySettings to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PrivacySettings(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PrivacySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrivacySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Proximity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Proximity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("precision_radius")
		s.PrecisionRadius.Encode(e)
	}
	{
		e.FieldStart("confidence")
		e.Float32(s.Confidence)
	}
}

var jsonFieldsNameOfProximity = [3]string{
	0: "id",
	1: "precision_radius",
	2: "confidence",
}

// Decode decodes Proximity from json.
func (s *Proximity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Proximity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "precision_radius":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PrecisionRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precision_radius\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Confidence = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Proximity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProximity) {
					name = jsonFieldsNameOfProximity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Proximity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Proximity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProximityPrecisionRadius as json.
func (s ProximityPrecisionRadius) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes ProximityPrecisionRadius from json.
func (s *ProximityPrecisionRadius) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProximityPrecisionRadius to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = ProximityPrecisionRadius(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProximityPrecisionRadius) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProximityPrecisionRadius) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Proxy as json.
func (s Proxy) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Proxy from json.
func (s *Proxy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Proxy to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Proxy(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Proxy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Proxy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyConfidence as json.
func (s ProxyConfidence) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyConfidence from json.
func (s *ProxyConfidence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyConfidence to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyConfidence(v) {
	case ProxyConfidenceLow:
		*s = ProxyConfidenceLow
	case ProxyConfidenceMedium:
		*s = ProxyConfidenceMedium
	case ProxyConfidenceHigh:
		*s = ProxyConfidenceHigh
	default:
		*s = ProxyConfidence(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxyDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxyDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("proxy_type")
		s.ProxyType.Encode(e)
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
}

var jsonFieldsNameOfProxyDetails = [3]string{
	0: "proxy_type",
	1: "last_seen_at",
	2: "provider",
}

// Decode decodes ProxyDetails from json.
func (s *ProxyDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proxy_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ProxyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxy_type\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProxyDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProxyDetails) {
					name = jsonFieldsNameOfProxyDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxyDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyDetailsProxyType as json.
func (s ProxyDetailsProxyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyDetailsProxyType from json.
func (s *ProxyDetailsProxyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyDetailsProxyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyDetailsProxyType(v) {
	case ProxyDetailsProxyTypeResidential:
		*s = ProxyDetailsProxyTypeResidential
	case ProxyDetailsProxyTypeDataCenter:
		*s = ProxyDetailsProxyTypeDataCenter
	default:
		*s = ProxyDetailsProxyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyDetailsProxyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyDetailsProxyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RawDeviceAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RawDeviceAttributes) encodeFields(e *jx.Encoder) {
	{
		if s.FontPreferences.Set {
			e.FieldStart("font_preferences")
			s.FontPreferences.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.Fonts != nil {
			e.FieldStart("fonts")
			s.Fonts.Encode(e)
		}
	}
	{
		if s.DeviceMemory.Set {
			e.FieldStart("device_memory")
			s.DeviceMemory.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.Canvas.Set {
			e.FieldStart("canvas")
			s.Canvas.Encode(e)
		}
	}
	{
		if s.Languages != nil {
			e.FieldStart("languages")
			s.Languages.Encode(e)
		}
	}
	{
		if s.WebglExtensions.Set {
			e.FieldStart("webgl_extensions")
			s.WebglExtensions.Encode(e)
		}
	}
	{
		if s.WebglBasics.Set {
			e.FieldStart("webgl_basics")
			s.WebglBasics.Encode(e)
		}
	}
	{
		if s.ScreenResolution != nil {
			e.FieldStart("screen_resolution")
			s.ScreenResolution.Encode(e)
		}
	}
	{
		if s.TouchSupport.Set {
			e.FieldStart("touch_support")
			s.TouchSupport.Encode(e)
		}
	}
	{
		if s.Oscpu.Set {
			e.FieldStart("oscpu")
			s.Oscpu.Encode(e)
		}
	}
	{
		if s.Architecture.Set {
			e.FieldStart("architecture")
			s.Architecture.Encode(e)
		}
	}
	{
		if s.CookiesEnabled.Set {
			e.FieldStart("cookies_enabled")
			s.CookiesEnabled.Encode(e)
		}
	}
	{
		if s.HardwareConcurrency.Set {
			e.FieldStart("hardware_concurrency")
			s.HardwareConcurrency.Encode(e)
		}
	}
	{
		if s.DateTimeLocale.Set {
			e.FieldStart("date_time_locale")
			s.DateTimeLocale.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.ColorDepth.Set {
			e.FieldStart("color_depth")
			s.ColorDepth.Encode(e)
		}
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.SessionStorage.Set {
			e.FieldStart("session_storage")
			s.SessionStorage.Encode(e)
		}
	}
	{
		if s.LocalStorage.Set {
			e.FieldStart("local_storage")
			s.LocalStorage.Encode(e)
		}
	}
	{
		if s.Audio.Set {
			e.FieldStart("audio")
			s.Audio.Encode(e)
		}
	}
	{
		if s.Plugins != nil {
			e.FieldStart("plugins")
			s.Plugins.Encode(e)
		}
	}
	{
		if s.IndexedDb.Set {
			e.FieldStart("indexed_db")
			s.IndexedDb.Encode(e)
		}
	}
	{
		if s.Math.Set {
			e.FieldStart("math")
			s.Math.Encode(e)
		}
	}
}

var jsonFieldsNameOfRawDeviceAttributes = [25]string{
	0:  "font_preferences",
	1:  "emoji",
	2:  "fonts",
	3:  "device_memory",
	4:  "timezone",
	5:  "canvas",
	6:  "languages",
	7:  "webgl_extensions",
	8:  "webgl_basics",
	9:  "screen_resolution",
	10: "touch_support",
	11: "oscpu",
	12: "architecture",
	13: "cookies_enabled",
	14: "hardware_concurrency",
	15: "date_time_locale",
	16: "vendor",
	17: "color_depth",
	18: "platform",
	19: "session_storage",
	20: "local_storage",
	21: "audio",
	22: "plugins",
	23: "indexed_db",
	24: "math",
}

// Decode decodes RawDeviceAttributes from json.
func (s *RawDeviceAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RawDeviceAttributes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "font_preferences":
			if err := func() error {
				s.FontPreferences.Reset()
				if err := s.FontPreferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"font_preferences\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "fonts":
			if err := func() error {
				if err := s.Fonts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fonts\"")
			}
		case "device_memory":
			if err := func() error {
				s.DeviceMemory.Reset()
				if err := s.DeviceMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device_memory\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "canvas":
			if err := func() error {
				s.Canvas.Reset()
				if err := s.Canvas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canvas\"")
			}
		case "languages":
			if err := func() error {
				if err := s.Languages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages\"")
			}
		case "webgl_extensions":
			if err := func() error {
				s.WebglExtensions.Reset()
				if err := s.WebglExtensions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webgl_extensions\"")
			}
		case "webgl_basics":
			if err := func() error {
				s.WebglBasics.Reset()
				if err := s.WebglBasics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webgl_basics\"")
			}
		case "screen_resolution":
			if err := func() error {
				if err := s.ScreenResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"screen_resolution\"")
			}
		case "touch_support":
			if err := func() error {
				s.TouchSupport.Reset()
				if err := s.TouchSupport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"touch_support\"")
			}
		case "oscpu":
			if err := func() error {
				s.Oscpu.Reset()
				if err := s.Oscpu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oscpu\"")
			}
		case "architecture":
			if err := func() error {
				s.Architecture.Reset()
				if err := s.Architecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "cookies_enabled":
			if err := func() error {
				s.CookiesEnabled.Reset()
				if err := s.CookiesEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cookies_enabled\"")
			}
		case "hardware_concurrency":
			if err := func() error {
				s.HardwareConcurrency.Reset()
				if err := s.HardwareConcurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardware_concurrency\"")
			}
		case "date_time_locale":
			if err := func() error {
				s.DateTimeLocale.Reset()
				if err := s.DateTimeLocale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_time_locale\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "color_depth":
			if err := func() error {
				s.ColorDepth.Reset()
				if err := s.ColorDepth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color_depth\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "session_storage":
			if err := func() error {
				s.SessionStorage.Reset()
				if err := s.SessionStorage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_storage\"")
			}
		case "local_storage":
			if err := func() error {
				s.LocalStorage.Reset()
				if err := s.LocalStorage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"local_storage\"")
			}
		case "audio":
			if err := func() error {
				s.Audio.Reset()
				if err := s.Audio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "plugins":
			if err := func() error {
				if err := s.Plugins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plugins\"")
			}
		case "indexed_db":
			if err := func() error {
				s.IndexedDb.Reset()
				if err := s.IndexedDb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexed_db\"")
			}
		case "math":
			if err := func() error {
				s.Math.Reset()
				if err := s.Math.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"math\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RawDeviceAttributes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RawDeviceAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RawDeviceAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Replayed as json.
func (s Replayed) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Replayed from json.
func (s *Replayed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Replayed to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Replayed(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Replayed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Replayed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestHeaderModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestHeaderModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Remove != nil {
			e.FieldStart("remove")
			e.ArrStart()
			for _, elem := range s.Remove {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Set != nil {
			e.FieldStart("set")
			e.ArrStart()
			for _, elem := range s.Set {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Append != nil {
			e.FieldStart("append")
			e.ArrStart()
			for _, elem := range s.Append {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRequestHeaderModifications = [3]string{
	0: "remove",
	1: "set",
	2: "append",
}

// Decode decodes RequestHeaderModifications from json.
func (s *RequestHeaderModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestHeaderModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remove":
			if err := func() error {
				s.Remove = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Remove = append(s.Remove, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove\"")
			}
		case "set":
			if err := func() error {
				s.Set = make([]RuleActionHeaderField, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleActionHeaderField
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Set = append(s.Set, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"set\"")
			}
		case "append":
			if err := func() error {
				s.Append = make([]RuleActionHeaderField, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleActionHeaderField
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Append = append(s.Append, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"append\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestHeaderModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestHeaderModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestHeaderModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootApps as json.
func (s RootApps) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes RootApps from json.
func (s *RootApps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootApps to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RootApps(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RootApps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootApps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleActionBody as json.
func (s RuleActionBody) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RuleActionBody from json.
func (s *RuleActionBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionBody to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RuleActionBody(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleActionBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleActionHeaderField) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleActionHeaderField) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfRuleActionHeaderField = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes RuleActionHeaderField from json.
func (s *RuleActionHeaderField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionHeaderField to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleActionHeaderField")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleActionHeaderField) {
					name = jsonFieldsNameOfRuleActionHeaderField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleActionHeaderField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionHeaderField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleActionType as json.
func (s RuleActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RuleActionType from json.
func (s *RuleActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RuleActionType(v) {
	case RuleActionTypeAllow:
		*s = RuleActionTypeAllow
	case RuleActionTypeBlock:
		*s = RuleActionTypeBlock
	default:
		*s = RuleActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleExpression as json.
func (s RuleExpression) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RuleExpression from json.
func (s *RuleExpression) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleExpression to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RuleExpression(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleExpression) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleExpression) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleId as json.
func (s RuleId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RuleId from json.
func (s *RuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RuleId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RulesetId as json.
func (s RulesetId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RulesetId from json.
func (s *RulesetId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RulesetId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RulesetId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RulesetId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RulesetId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SDK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SDK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSDK = [3]string{
	0: "platform",
	1: "version",
	2: "integrations",
}

// Decode decodes SDK from json.
func (s *SDK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SDK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "platform":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]Integration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Integration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SDK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSDK) {
					name = jsonFieldsNameOfSDK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SDK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SDK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SDKPlatform as json.
func (s SDKPlatform) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SDKPlatform from json.
func (s *SDKPlatform) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SDKPlatform to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SDKPlatform(v) {
	case SDKPlatformJs:
		*s = SDKPlatformJs
	case SDKPlatformAndroid:
		*s = SDKPlatformAndroid
	case SDKPlatformIos:
		*s = SDKPlatformIos
	case SDKPlatformUnknown:
		*s = SDKPlatformUnknown
	default:
		*s = SDKPlatform(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SDKPlatform) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SDKPlatform) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScreenResolution as json.
func (s ScreenResolution) Encode(e *jx.Encoder) {
	unwrapped := []int32(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			e.Int32(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ScreenResolution from json.
func (s *ScreenResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScreenResolution to nil")
	}
	var unwrapped []int32
	if err := func() error {
		unwrapped = make([]int32, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int32
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScreenResolution(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ScreenResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScreenResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEventsBadRequest as json.
func (s *SearchEventsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEventsBadRequest from json.
func (s *SearchEventsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEventsBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEventsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEventsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEventsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEventsForbidden as json.
func (s *SearchEventsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEventsForbidden from json.
func (s *SearchEventsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEventsForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEventsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEventsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEventsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEventsInternalServerError as json.
func (s *SearchEventsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEventsInternalServerError from json.
func (s *SearchEventsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEventsInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEventsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEventsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEventsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionStorage as json.
func (s SessionStorage) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes SessionStorage from json.
func (s *SessionStorage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionStorage to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SessionStorage(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StatusCode as json.
func (s StatusCode) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes StatusCode from json.
func (s *StatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusCode to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StatusCode(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupplementaryIDHighRecall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupplementaryIDHighRecall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("visitor_id")
		e.Str(s.VisitorID)
	}
	{
		e.FieldStart("visitor_found")
		e.Bool(s.VisitorFound)
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
	{
		if s.FirstSeenAt.Set {
			e.FieldStart("first_seen_at")
			s.FirstSeenAt.Encode(e)
		}
	}
	{
		if s.LastSeenAt.Set {
			e.FieldStart("last_seen_at")
			s.LastSeenAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupplementaryIDHighRecall = [5]string{
	0: "visitor_id",
	1: "visitor_found",
	2: "confidence",
	3: "first_seen_at",
	4: "last_seen_at",
}

// Decode decodes SupplementaryIDHighRecall from json.
func (s *SupplementaryIDHighRecall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupplementaryIDHighRecall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visitor_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VisitorID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visitor_id\"")
			}
		case "visitor_found":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.VisitorFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visitor_found\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "first_seen_at":
			if err := func() error {
				s.FirstSeenAt.Reset()
				if err := s.FirstSeenAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_seen_at\"")
			}
		case "last_seen_at":
			if err := func() error {
				s.LastSeenAt.Reset()
				if err := s.LastSeenAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupplementaryIDHighRecall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSupplementaryIDHighRecall) {
					name = jsonFieldsNameOfSupplementaryIDHighRecall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupplementaryIDHighRecall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupplementaryIDHighRecall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Suspect as json.
func (s Suspect) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Suspect from json.
func (s *Suspect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Suspect to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Suspect(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Suspect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Suspect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuspectScore as json.
func (s SuspectScore) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes SuspectScore from json.
func (s *SuspectScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuspectScore to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SuspectScore(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuspectScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuspectScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tags) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfTags = [0]string{}

// Decode decodes Tags from json.
func (s *Tags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tags to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode Tags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tampering as json.
func (s Tampering) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Tampering from json.
func (s *Tampering) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tampering to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Tampering(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tampering) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tampering) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TamperingDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TamperingDetails) encodeFields(e *jx.Encoder) {
	{
		if s.AnomalyScore.Set {
			e.FieldStart("anomaly_score")
			s.AnomalyScore.Encode(e)
		}
	}
	{
		if s.AntiDetectBrowser.Set {
			e.FieldStart("anti_detect_browser")
			s.AntiDetectBrowser.Encode(e)
		}
	}
}

var jsonFieldsNameOfTamperingDetails = [2]string{
	0: "anomaly_score",
	1: "anti_detect_browser",
}

// Decode decodes TamperingDetails from json.
func (s *TamperingDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TamperingDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "anomaly_score":
			if err := func() error {
				s.AnomalyScore.Reset()
				if err := s.AnomalyScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anomaly_score\"")
			}
		case "anti_detect_browser":
			if err := func() error {
				s.AntiDetectBrowser.Reset()
				if err := s.AntiDetectBrowser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anti_detect_browser\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TamperingDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TamperingDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TamperingDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Timestamp as json.
func (s Timestamp) Encode(e *jx.Encoder) {
	unwrapped := int64(s)

	e.Int64(unwrapped)
}

// Decode decodes Timestamp from json.
func (s *Timestamp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Timestamp to nil")
	}
	var unwrapped int64
	if err := func() error {
		v, err := d.Int64()
		unwrapped = int64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Timestamp(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Timestamp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Timestamp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Timezone as json.
func (s Timezone) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Timezone from json.
func (s *Timezone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Timezone to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Timezone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Timezone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Timezone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TouchSupport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TouchSupport) encodeFields(e *jx.Encoder) {
	{
		if s.TouchEvent.Set {
			e.FieldStart("touch_event")
			s.TouchEvent.Encode(e)
		}
	}
	{
		if s.TouchStart.Set {
			e.FieldStart("touch_start")
			s.TouchStart.Encode(e)
		}
	}
	{
		if s.MaxTouchPoints.Set {
			e.FieldStart("max_touch_points")
			s.MaxTouchPoints.Encode(e)
		}
	}
}

var jsonFieldsNameOfTouchSupport = [3]string{
	0: "touch_event",
	1: "touch_start",
	2: "max_touch_points",
}

// Decode decodes TouchSupport from json.
func (s *TouchSupport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TouchSupport to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "touch_event":
			if err := func() error {
				s.TouchEvent.Reset()
				if err := s.TouchEvent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"touch_event\"")
			}
		case "touch_start":
			if err := func() error {
				s.TouchStart.Reset()
				if err := s.TouchStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"touch_start\"")
			}
		case "max_touch_points":
			if err := func() error {
				s.MaxTouchPoints.Reset()
				if err := s.MaxTouchPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_touch_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TouchSupport")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TouchSupport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TouchSupport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes URL as json.
func (s URL) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes URL from json.
func (s *URL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URL to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = URL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventBadRequest as json.
func (s *UpdateEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventBadRequest from json.
func (s *UpdateEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventConflict as json.
func (s *UpdateEventConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventConflict from json.
func (s *UpdateEventConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventForbidden as json.
func (s *UpdateEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventForbidden from json.
func (s *UpdateEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEventNotFound as json.
func (s *UpdateEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEventNotFound from json.
func (s *UpdateEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEventNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAgent as json.
func (s UserAgent) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes UserAgent from json.
func (s *UserAgent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAgent to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserAgent(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserAgent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAgent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Velocity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Velocity) encodeFields(e *jx.Encoder) {
	{
		if s.DistinctIP.Set {
			e.FieldStart("distinct_ip")
			s.DistinctIP.Encode(e)
		}
	}
	{
		if s.DistinctLinkedID.Set {
			e.FieldStart("distinct_linked_id")
			s.DistinctLinkedID.Encode(e)
		}
	}
	{
		if s.DistinctCountry.Set {
			e.FieldStart("distinct_country")
			s.DistinctCountry.Encode(e)
		}
	}
	{
		if s.Events.Set {
			e.FieldStart("events")
			s.Events.Encode(e)
		}
	}
	{
		if s.IPEvents.Set {
			e.FieldStart("ip_events")
			s.IPEvents.Encode(e)
		}
	}
	{
		if s.DistinctIPByLinkedID.Set {
			e.FieldStart("distinct_ip_by_linked_id")
			s.DistinctIPByLinkedID.Encode(e)
		}
	}
	{
		if s.DistinctVisitorIDByLinkedID.Set {
			e.FieldStart("distinct_visitor_id_by_linked_id")
			s.DistinctVisitorIDByLinkedID.Encode(e)
		}
	}
}

var jsonFieldsNameOfVelocity = [7]string{
	0: "distinct_ip",
	1: "distinct_linked_id",
	2: "distinct_country",
	3: "events",
	4: "ip_events",
	5: "distinct_ip_by_linked_id",
	6: "distinct_visitor_id_by_linked_id",
}

// Decode decodes Velocity from json.
func (s *Velocity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Velocity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinct_ip":
			if err := func() error {
				s.DistinctIP.Reset()
				if err := s.DistinctIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinct_ip\"")
			}
		case "distinct_linked_id":
			if err := func() error {
				s.DistinctLinkedID.Reset()
				if err := s.DistinctLinkedID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinct_linked_id\"")
			}
		case "distinct_country":
			if err := func() error {
				s.DistinctCountry.Reset()
				if err := s.DistinctCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinct_country\"")
			}
		case "events":
			if err := func() error {
				s.Events.Reset()
				if err := s.Events.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "ip_events":
			if err := func() error {
				s.IPEvents.Reset()
				if err := s.IPEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_events\"")
			}
		case "distinct_ip_by_linked_id":
			if err := func() error {
				s.DistinctIPByLinkedID.Reset()
				if err := s.DistinctIPByLinkedID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinct_ip_by_linked_id\"")
			}
		case "distinct_visitor_id_by_linked_id":
			if err := func() error {
				s.DistinctVisitorIDByLinkedID.Reset()
				if err := s.DistinctVisitorIDByLinkedID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinct_visitor_id_by_linked_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Velocity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Velocity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Velocity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VelocityData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VelocityData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("5_minutes")
		e.Int(s.R5Minutes)
	}
	{
		e.FieldStart("1_hour")
		e.Int(s.R1Hour)
	}
	{
		if s.R24Hours.Set {
			e.FieldStart("24_hours")
			s.R24Hours.Encode(e)
		}
	}
}

var jsonFieldsNameOfVelocityData = [3]string{
	0: "5_minutes",
	1: "1_hour",
	2: "24_hours",
}

// Decode decodes VelocityData from json.
func (s *VelocityData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VelocityData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "5_minutes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.R5Minutes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"5_minutes\"")
			}
		case "1_hour":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.R1Hour = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"1_hour\"")
			}
		case "24_hours":
			if err := func() error {
				s.R24Hours.Reset()
				if err := s.R24Hours.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"24_hours\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VelocityData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVelocityData) {
					name = jsonFieldsNameOfVelocityData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VelocityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VelocityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Vendor as json.
func (s Vendor) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Vendor from json.
func (s *Vendor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vendor to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Vendor(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Vendor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vendor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VirtualMachine as json.
func (s VirtualMachine) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes VirtualMachine from json.
func (s *VirtualMachine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VirtualMachine to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VirtualMachine(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VirtualMachine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VirtualMachine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Vpn as json.
func (s Vpn) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes Vpn from json.
func (s *Vpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vpn to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Vpn(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Vpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnConfidence as json.
func (s VpnConfidence) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VpnConfidence from json.
func (s *VpnConfidence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VpnConfidence to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VpnConfidence(v) {
	case VpnConfidenceLow:
		*s = VpnConfidenceLow
	case VpnConfidenceMedium:
		*s = VpnConfidenceMedium
	case VpnConfidenceHigh:
		*s = VpnConfidenceHigh
	default:
		*s = VpnConfidence(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VpnConfidence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VpnConfidence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VpnMethods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VpnMethods) encodeFields(e *jx.Encoder) {
	{
		if s.TimezoneMismatch.Set {
			e.FieldStart("timezone_mismatch")
			s.TimezoneMismatch.Encode(e)
		}
	}
	{
		if s.PublicVpn.Set {
			e.FieldStart("public_vpn")
			s.PublicVpn.Encode(e)
		}
	}
	{
		if s.AuxiliaryMobile.Set {
			e.FieldStart("auxiliary_mobile")
			s.AuxiliaryMobile.Encode(e)
		}
	}
	{
		if s.OsMismatch.Set {
			e.FieldStart("os_mismatch")
			s.OsMismatch.Encode(e)
		}
	}
	{
		if s.Relay.Set {
			e.FieldStart("relay")
			s.Relay.Encode(e)
		}
	}
}

var jsonFieldsNameOfVpnMethods = [5]string{
	0: "timezone_mismatch",
	1: "public_vpn",
	2: "auxiliary_mobile",
	3: "os_mismatch",
	4: "relay",
}

// Decode decodes VpnMethods from json.
func (s *VpnMethods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VpnMethods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timezone_mismatch":
			if err := func() error {
				s.TimezoneMismatch.Reset()
				if err := s.TimezoneMismatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone_mismatch\"")
			}
		case "public_vpn":
			if err := func() error {
				s.PublicVpn.Reset()
				if err := s.PublicVpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_vpn\"")
			}
		case "auxiliary_mobile":
			if err := func() error {
				s.AuxiliaryMobile.Reset()
				if err := s.AuxiliaryMobile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auxiliary_mobile\"")
			}
		case "os_mismatch":
			if err := func() error {
				s.OsMismatch.Reset()
				if err := s.OsMismatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os_mismatch\"")
			}
		case "relay":
			if err := func() error {
				s.Relay.Reset()
				if err := s.Relay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VpnMethods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VpnMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VpnMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnOriginCountry as json.
func (s VpnOriginCountry) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes VpnOriginCountry from json.
func (s *VpnOriginCountry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VpnOriginCountry to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VpnOriginCountry(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VpnOriginCountry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VpnOriginCountry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VpnOriginTimezone as json.
func (s VpnOriginTimezone) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes VpnOriginTimezone from json.
func (s *VpnOriginTimezone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VpnOriginTimezone to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VpnOriginTimezone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VpnOriginTimezone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VpnOriginTimezone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebGlBasics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebGlBasics) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.VendorUnmasked.Set {
			e.FieldStart("vendor_unmasked")
			s.VendorUnmasked.Encode(e)
		}
	}
	{
		if s.Renderer.Set {
			e.FieldStart("renderer")
			s.Renderer.Encode(e)
		}
	}
	{
		if s.RendererUnmasked.Set {
			e.FieldStart("renderer_unmasked")
			s.RendererUnmasked.Encode(e)
		}
	}
	{
		if s.ShadingLanguageVersion.Set {
			e.FieldStart("shading_language_version")
			s.ShadingLanguageVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebGlBasics = [6]string{
	0: "version",
	1: "vendor",
	2: "vendor_unmasked",
	3: "renderer",
	4: "renderer_unmasked",
	5: "shading_language_version",
}

// Decode decodes WebGlBasics from json.
func (s *WebGlBasics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebGlBasics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "vendor_unmasked":
			if err := func() error {
				s.VendorUnmasked.Reset()
				if err := s.VendorUnmasked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor_unmasked\"")
			}
		case "renderer":
			if err := func() error {
				s.Renderer.Reset()
				if err := s.Renderer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"renderer\"")
			}
		case "renderer_unmasked":
			if err := func() error {
				s.RendererUnmasked.Reset()
				if err := s.RendererUnmasked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"renderer_unmasked\"")
			}
		case "shading_language_version":
			if err := func() error {
				s.ShadingLanguageVersion.Reset()
				if err := s.ShadingLanguageVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shading_language_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebGlBasics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebGlBasics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebGlBasics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebGlExtensions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebGlExtensions) encodeFields(e *jx.Encoder) {
	{
		if s.ContextAttributes.Set {
			e.FieldStart("context_attributes")
			s.ContextAttributes.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.ShaderPrecisions.Set {
			e.FieldStart("shader_precisions")
			s.ShaderPrecisions.Encode(e)
		}
	}
	{
		if s.Extensions.Set {
			e.FieldStart("extensions")
			s.Extensions.Encode(e)
		}
	}
	{
		if s.ExtensionParameters.Set {
			e.FieldStart("extension_parameters")
			s.ExtensionParameters.Encode(e)
		}
	}
	{
		if s.UnsupportedExtensions != nil {
			e.FieldStart("unsupported_extensions")
			e.ArrStart()
			for _, elem := range s.UnsupportedExtensions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWebGlExtensions = [6]string{
	0: "context_attributes",
	1: "parameters",
	2: "shader_precisions",
	3: "extensions",
	4: "extension_parameters",
	5: "unsupported_extensions",
}

// Decode decodes WebGlExtensions from json.
func (s *WebGlExtensions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebGlExtensions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context_attributes":
			if err := func() error {
				s.ContextAttributes.Reset()
				if err := s.ContextAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_attributes\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "shader_precisions":
			if err := func() error {
				s.ShaderPrecisions.Reset()
				if err := s.ShaderPrecisions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shader_precisions\"")
			}
		case "extensions":
			if err := func() error {
				s.Extensions.Reset()
				if err := s.Extensions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extensions\"")
			}
		case "extension_parameters":
			if err := func() error {
				s.ExtensionParameters.Reset()
				if err := s.ExtensionParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extension_parameters\"")
			}
		case "unsupported_extensions":
			if err := func() error {
				s.UnsupportedExtensions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UnsupportedExtensions = append(s.UnsupportedExtensions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unsupported_extensions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebGlExtensions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebGlExtensions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebGlExtensions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
