/*
Server API

Fingerprint Server API allows you to get, search, and update Events in a server environment. It can be used for data exports, decision-making, and data analysis scenarios. Server API is intended for server-side usage, it's not intended to be used from the client side, whether it's a browser or a mobile device.

API version: 4
Contact: support@fingerprint.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fingerprint

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// FingerprintAPIService FingerprintAPI service
type FingerprintAPIService service

type ApiDeleteVisitorDataRequest struct {
	ApiService *FingerprintAPIService
	visitorID  string
}

func (r ApiDeleteVisitorDataRequest) Execute(ctx context.Context) (*http.Response, error) {
	return r.ApiService.DeleteVisitorDataExecute(ctx, r)
}

/*
DeleteVisitorData Delete data by visitor ID

Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations.

### Which data is deleted?
- Browser (or device) properties
- Identification requests made from this browser (or device)

#### Browser (or device) properties
- Represents the data that Fingerprint collected from this specific browser (or device) and everything inferred and derived from it.
- Upon request to delete, this data is deleted asynchronously (typically within a few minutes) and it will no longer be used to identify this browser (or device) for your [Fingerprint Workspace](https://dev.fingerprint.com/docs/glossary#fingerprint-workspace).

#### Identification requests made from this browser (or device)
- Fingerprint stores the identification requests made from a browser (or device) for up to 30 (or 90) days depending on your plan. To learn more, see [Data Retention](https://dev.fingerprint.com/docs/regions#data-retention).
- Upon request to delete, the identification requests that were made by this browser
  - Within the past 10 days are deleted within 24 hrs.
  - Outside of 10 days are allowed to purge as per your data retention period.

### Corollary
After requesting to delete a visitor ID,
- If the same browser (or device) requests to identify, it will receive a different visitor ID.
- If you request [`/v4/events` API](https://dev.fingerprint.com/reference/getevent) with an `event_id` that was made outside of the 10 days, you will still receive a valid response.

### Interested?
Please [contact our support team](https://fingerprint.com/support/) to enable it for you. Otherwise, you will receive a 403.

	@param visitorID The [visitor ID](https://dev.fingerprint.com/reference/get-function#visitorid) you want to delete.
	@return ApiDeleteVisitorDataRequest
*/
func (a *FingerprintAPIService) DeleteVisitorData(visitorID string) ApiDeleteVisitorDataRequest {
	return ApiDeleteVisitorDataRequest{
		ApiService: a,
		visitorID:  visitorID,
	}
}

// Execute executes the request
func (a *FingerprintAPIService) DeleteVisitorDataExecute(ctx context.Context, r ApiDeleteVisitorDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(ctx, "FingerprintAPIService.DeleteVisitorData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visitors/{visitor_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"visitor_id"+"}", url.PathEscape(parameterValueToString(r.visitorID, "visitorID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEventRequest struct {
	ApiService *FingerprintAPIService
	eventID    string
	rulesetID  *string
}

// The ID of the ruleset to evaluate against the event, producing the action to take for this event. The resulting action is returned in the &#x60;rule_action&#x60; attribute of the response.
func (r ApiGetEventRequest) RulesetID(rulesetID string) ApiGetEventRequest {
	r.rulesetID = &rulesetID
	return r
}

func (r ApiGetEventRequest) Execute(ctx context.Context) (*Event, *http.Response, error) {
	return r.ApiService.GetEventExecute(ctx, r)
}

/*
GetEvent Get an event by event ID

Get a detailed analysis of an individual identification event, including Smart Signals.

Use `event_id` as the URL path parameter. This API method is scoped to a request, i.e. all returned information is by `event_id`.

	@param eventID The unique [identifier](https://dev.fingerprint.com/reference/get-function#requestid) of each identification request (`requestId` can be used in its place).
	@return ApiGetEventRequest
*/
func (a *FingerprintAPIService) GetEvent(eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		eventID:    eventID,
	}
}

// Execute executes the request
//
//	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//	@return Event
func (a *FingerprintAPIService) GetEventExecute(ctx context.Context, r ApiGetEventRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(ctx, "FingerprintAPIService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{event_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventID, "eventID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.rulesetID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ruleset_id", r.rulesetID, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchEventsRequest struct {
	ApiService        *FingerprintAPIService
	limit             *int32
	paginationKey     *string
	visitorID         *string
	bot               *SearchEventsBot
	iPAddress         *string
	asn               *string
	linkedID          *string
	uRL               *string
	bundleID          *string
	packageName       *string
	origin            *string
	start             *int64
	end               *int64
	reverse           *bool
	suspect           *bool
	vPN               *bool
	virtualMachine    *bool
	tampering         *bool
	antiDetectBrowser *bool
	incognito         *bool
	privacySettings   *bool
	jailbroken        *bool
	frida             *bool
	factoryReset      *bool
	clonedApp         *bool
	emulator          *bool
	rootApps          *bool
	vPNConfidence     *SearchEventsVPNConfidence
	minSuspectScore   *float32
	developerTools    *bool
	locationSpoofing  *bool
	mITMAttack        *bool
	proxy             *bool
	sDKVersion        *string
	sDKPlatform       *SearchEventsSDKPlatform
	environment       *[]string
	proximityID       *string
	totalHits         *int64
	torNode           *bool
}

// Limit the number of events returned.
func (r ApiSearchEventsRequest) Limit(limit int32) ApiSearchEventsRequest {
	r.limit = &limit
	return r
}

// Use &#x60;pagination_key&#x60; to get the next page of results.  When more results are available (e.g., you requested up to 100 results for your query using &#x60;limit&#x60;, but there are more than 100 events total matching your request), the &#x60;pagination_key&#x60; field is added to the response. The pagination key is an arbitrary string that should not be interpreted in any way and should be passed as-is. In the following request, use that value in the &#x60;pagination_key&#x60; parameter to get the next page of results:  1. First request, returning most recent 200 events: &#x60;GET api-base-url/events?limit&#x3D;100&#x60; 2. Use &#x60;response.pagination_key&#x60; to get the next page of results: &#x60;GET api-base-url/events?limit&#x3D;100&amp;pagination_key&#x3D;1740815825085&#x60;
func (r ApiSearchEventsRequest) PaginationKey(paginationKey string) ApiSearchEventsRequest {
	r.paginationKey = &paginationKey
	return r
}

// Unique [visitor identifier](https://dev.fingerprint.com/reference/get-function#visitorid) issued by Fingerprint Identification and all active Smart Signals. Filter for events matching this &#x60;visitor_id&#x60;.
func (r ApiSearchEventsRequest) VisitorID(visitorID string) ApiSearchEventsRequest {
	r.visitorID = &visitorID
	return r
}

// Filter events by the Bot Detection result, specifically:   &#x60;all&#x60; - events where any kind of bot was detected.   &#x60;good&#x60; - events where a good bot was detected.   &#x60;bad&#x60; - events where a bad bot was detected.   &#x60;none&#x60; - events where no bot was detected. &gt; Note: When using this parameter, only events with the &#x60;bot&#x60; property set to a valid value are returned. Events without a &#x60;bot&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Bot(bot SearchEventsBot) ApiSearchEventsRequest {
	r.bot = &bot
	return r
}

// Filter events by IP address or IP range (if CIDR notation is used). If CIDR notation is not used, a /32 for IPv4 or /128 for IPv6 is assumed. Examples of range based queries: 10.0.0.0/24, 192.168.0.1/32
func (r ApiSearchEventsRequest) IPAddress(iPAddress string) ApiSearchEventsRequest {
	r.iPAddress = &iPAddress
	return r
}

// Filter events by the ASN associated with the event&#39;s IP address. This corresponds to the &#x60;ip_info.(v4|v6).asn&#x60; property in the response.
func (r ApiSearchEventsRequest) Asn(asn string) ApiSearchEventsRequest {
	r.asn = &asn
	return r
}

// Filter events by your custom identifier.  You can use [linked Ids](https://dev.fingerprint.com/reference/get-function#linkedid) to associate identification requests with your own identifier, for example, session Id, purchase Id, or transaction Id. You can then use this &#x60;linked_id&#x60; parameter to retrieve all events associated with your custom identifier.
func (r ApiSearchEventsRequest) LinkedID(linkedID string) ApiSearchEventsRequest {
	r.linkedID = &linkedID
	return r
}

// Filter events by the URL (&#x60;url&#x60; property) associated with the event.
func (r ApiSearchEventsRequest) URL(uRL string) ApiSearchEventsRequest {
	r.uRL = &uRL
	return r
}

// Filter events by the Bundle ID (iOS) associated with the event.
func (r ApiSearchEventsRequest) BundleID(bundleID string) ApiSearchEventsRequest {
	r.bundleID = &bundleID
	return r
}

// Filter events by the Package Name (Android) associated with the event.
func (r ApiSearchEventsRequest) PackageName(packageName string) ApiSearchEventsRequest {
	r.packageName = &packageName
	return r
}

// Filter events by the origin field of the event. This is applicable to web events only (e.g., https://example.com)
func (r ApiSearchEventsRequest) Origin(origin string) ApiSearchEventsRequest {
	r.origin = &origin
	return r
}

// Filter events with a timestamp greater than the start time, in Unix time (milliseconds).
func (r ApiSearchEventsRequest) Start(start int64) ApiSearchEventsRequest {
	r.start = &start
	return r
}

// Filter events with a timestamp smaller than the end time, in Unix time (milliseconds).
func (r ApiSearchEventsRequest) End(end int64) ApiSearchEventsRequest {
	r.end = &end
	return r
}

// Sort events in reverse timestamp order.
func (r ApiSearchEventsRequest) Reverse(reverse bool) ApiSearchEventsRequest {
	r.reverse = &reverse
	return r
}

// Filter events previously tagged as suspicious via the [Update API](https://dev.fingerprint.com/reference/updateevent). &gt; Note: When using this parameter, only events with the &#x60;suspect&#x60; property explicitly set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events with undefined &#x60;suspect&#x60; property are left out of the response.
func (r ApiSearchEventsRequest) Suspect(suspect bool) ApiSearchEventsRequest {
	r.suspect = &suspect
	return r
}

// Filter events by VPN Detection result. &gt; Note: When using this parameter, only events with the &#x60;vpn&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;vpn&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) VPN(vPN bool) ApiSearchEventsRequest {
	r.vPN = &vPN
	return r
}

// Filter events by Virtual Machine Detection result. &gt; Note: When using this parameter, only events with the &#x60;virtual_machine&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;virtual_machine&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) VirtualMachine(virtualMachine bool) ApiSearchEventsRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Filter events by Browser Tampering Detection result. &gt; Note: When using this parameter, only events with the &#x60;tampering.result&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;tampering&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Tampering(tampering bool) ApiSearchEventsRequest {
	r.tampering = &tampering
	return r
}

// Filter events by Anti-detect Browser Detection result. &gt; Note: When using this parameter, only events with the &#x60;tampering.anti_detect_browser&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;tampering&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) AntiDetectBrowser(antiDetectBrowser bool) ApiSearchEventsRequest {
	r.antiDetectBrowser = &antiDetectBrowser
	return r
}

// Filter events by Browser Incognito Detection result. &gt; Note: When using this parameter, only events with the &#x60;incognito&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without an &#x60;incognito&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Incognito(incognito bool) ApiSearchEventsRequest {
	r.incognito = &incognito
	return r
}

// Filter events by Privacy Settings Detection result. &gt; Note: When using this parameter, only events with the &#x60;privacy_settings&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;privacy_settings&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) PrivacySettings(privacySettings bool) ApiSearchEventsRequest {
	r.privacySettings = &privacySettings
	return r
}

// Filter events by Jailbroken Device Detection result. &gt; Note: When using this parameter, only events with the &#x60;jailbroken&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;jailbroken&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Jailbroken(jailbroken bool) ApiSearchEventsRequest {
	r.jailbroken = &jailbroken
	return r
}

// Filter events by Frida Detection result. &gt; Note: When using this parameter, only events with the &#x60;frida&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;frida&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Frida(frida bool) ApiSearchEventsRequest {
	r.frida = &frida
	return r
}

// Filter events by Factory Reset Detection result. &gt; Note: When using this parameter, only events with a &#x60;factory_reset&#x60; time. Events without a &#x60;factory_reset&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) FactoryReset(factoryReset bool) ApiSearchEventsRequest {
	r.factoryReset = &factoryReset
	return r
}

// Filter events by Cloned App Detection result. &gt; Note: When using this parameter, only events with the &#x60;cloned_app&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;cloned_app&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) ClonedApp(clonedApp bool) ApiSearchEventsRequest {
	r.clonedApp = &clonedApp
	return r
}

// Filter events by Android Emulator Detection result. &gt; Note: When using this parameter, only events with the &#x60;emulator&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without an &#x60;emulator&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Emulator(emulator bool) ApiSearchEventsRequest {
	r.emulator = &emulator
	return r
}

// Filter events by Rooted Device Detection result. &gt; Note: When using this parameter, only events with the &#x60;root_apps&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;root_apps&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) RootApps(rootApps bool) ApiSearchEventsRequest {
	r.rootApps = &rootApps
	return r
}

// Filter events by VPN Detection result confidence level. &#x60;high&#x60; - events with high VPN Detection confidence. &#x60;medium&#x60; - events with medium VPN Detection confidence. &#x60;low&#x60; - events with low VPN Detection confidence. &gt; Note: When using this parameter, only events with the &#x60;vpn.confidence&#x60; property set to a valid value are returned. Events without a &#x60;vpn&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) VPNConfidence(vPNConfidence SearchEventsVPNConfidence) ApiSearchEventsRequest {
	r.vPNConfidence = &vPNConfidence
	return r
}

// Filter events with Suspect Score result above a provided minimum threshold. &gt; Note: When using this parameter, only events where the &#x60;suspect_score&#x60; property set to a value exceeding your threshold are returned. Events without a &#x60;suspect_score&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) MinSuspectScore(minSuspectScore float32) ApiSearchEventsRequest {
	r.minSuspectScore = &minSuspectScore
	return r
}

// Filter events by Developer Tools detection result. &gt; Note: When using this parameter, only events with the &#x60;developer_tools&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;developer_tools&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) DeveloperTools(developerTools bool) ApiSearchEventsRequest {
	r.developerTools = &developerTools
	return r
}

// Filter events by Location Spoofing detection result. &gt; Note: When using this parameter, only events with the &#x60;location_spoofing&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;location_spoofing&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) LocationSpoofing(locationSpoofing bool) ApiSearchEventsRequest {
	r.locationSpoofing = &locationSpoofing
	return r
}

// Filter events by MITM (Man-in-the-Middle) Attack detection result. &gt; Note: When using this parameter, only events with the &#x60;mitm_attack&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;mitm_attack&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) MITMAttack(mITMAttack bool) ApiSearchEventsRequest {
	r.mITMAttack = &mITMAttack
	return r
}

// Filter events by Proxy detection result. &gt; Note: When using this parameter, only events with the &#x60;proxy&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;proxy&#x60; Smart Signal result are left out of the response.
func (r ApiSearchEventsRequest) Proxy(proxy bool) ApiSearchEventsRequest {
	r.proxy = &proxy
	return r
}

// Filter events by a specific SDK version associated with the identification event (&#x60;sdk.version&#x60; property). Example: &#x60;3.11.14&#x60;
func (r ApiSearchEventsRequest) SDKVersion(sDKVersion string) ApiSearchEventsRequest {
	r.sDKVersion = &sDKVersion
	return r
}

// Filter events by the SDK Platform associated with the identification event (&#x60;sdk.platform&#x60; property) . &#x60;js&#x60; - Javascript agent (Web). &#x60;ios&#x60; - Apple iOS based devices. &#x60;android&#x60; - Android based devices.
func (r ApiSearchEventsRequest) SDKPlatform(sDKPlatform SearchEventsSDKPlatform) ApiSearchEventsRequest {
	r.sDKPlatform = &sDKPlatform
	return r
}

// Filter for events by providing one or more environment IDs (&#x60;environment_id&#x60; property).
func (r ApiSearchEventsRequest) Environment(environment []string) ApiSearchEventsRequest {
	r.environment = &environment
	return r
}

// Filter events by the most precise Proximity ID provided by default. &gt; Note: When using this parameter, only events with the &#x60;proximity.id&#x60; property matching the provided ID are returned. Events without a &#x60;proximity&#x60; result are left out of the response.
func (r ApiSearchEventsRequest) ProximityID(proximityID string) ApiSearchEventsRequest {
	r.proximityID = &proximityID
	return r
}

// When set, the response will include a &#x60;total_hits&#x60; property with a count of total query matches across all pages, up to the specified limit.
func (r ApiSearchEventsRequest) TotalHits(totalHits int64) ApiSearchEventsRequest {
	r.totalHits = &totalHits
	return r
}

// Filter events by Tor Node detection result. &gt; Note: When using this parameter, only events with the &#x60;tor_node&#x60; property set to &#x60;true&#x60; or &#x60;false&#x60; are returned. Events without a &#x60;tor_node&#x60; detection result are left out of the response.
func (r ApiSearchEventsRequest) TorNode(torNode bool) ApiSearchEventsRequest {
	r.torNode = &torNode
	return r
}

func (r ApiSearchEventsRequest) Execute(ctx context.Context) (*EventSearch, *http.Response, error) {
	return r.ApiService.SearchEventsExecute(ctx, r)
}

/*
SearchEvents Search events

## Search

The `/v4/events` endpoint provides a convenient way to search for past events based on specific parameters. Typical use cases and queries include:

- Searching for events associated with a single `visitor_id` within a time range to get historical behavior of a visitor.
- Searching for events associated with a single `linked_id` within a time range to get all events associated with your internal account identifier.
- Excluding all bot traffic from the query (`good` and `bad` bots)

If you don't provide `start` or `end` parameters, the default search range is the **last 7 days**.

### Filtering events with the `suspect` flag

The `/v4/events` endpoint unlocks a powerful method for fraud protection analytics. The `suspect` flag is exposed in all events where it was previously set by the update API.

You can also apply the `suspect` query parameter as a filter to find all potentially fraudulent activity that you previously marked as `suspect`. This helps identify patterns of fraudulent behavior.

### Environment scoping

If you use a secret key that is scoped to an environment, you will only get events associated with the same environment. With a workspace-scoped environment, you will get events from all environments.

Smart Signals not activated for your workspace or are not included in the response.

	@return ApiSearchEventsRequest
*/
func (a *FingerprintAPIService) SearchEvents() ApiSearchEventsRequest {
	return ApiSearchEventsRequest{
		ApiService: a,
	}
}

// Execute executes the request
//
//	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//	@return EventSearch
func (a *FingerprintAPIService) SearchEventsExecute(ctx context.Context, r ApiSearchEventsRequest) (*EventSearch, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(ctx, "FingerprintAPIService.SearchEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.paginationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination_key", r.paginationKey, "form", "")
	}
	if r.visitorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visitor_id", r.visitorID, "form", "")
	}
	if r.bot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bot", r.bot, "form", "")
	}
	if r.iPAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", r.iPAddress, "form", "")
	}
	if r.asn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asn", r.asn, "form", "")
	}
	if r.linkedID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linked_id", r.linkedID, "form", "")
	}
	if r.uRL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.uRL, "form", "")
	}
	if r.bundleID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundle_id", r.bundleID, "form", "")
	}
	if r.packageName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origin", r.origin, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.reverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reverse", r.reverse, "form", "")
	}
	if r.suspect != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspect", r.suspect, "form", "")
	}
	if r.vPN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vpn", r.vPN, "form", "")
	}
	if r.virtualMachine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", r.virtualMachine, "form", "")
	}
	if r.tampering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tampering", r.tampering, "form", "")
	}
	if r.antiDetectBrowser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anti_detect_browser", r.antiDetectBrowser, "form", "")
	}
	if r.incognito != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incognito", r.incognito, "form", "")
	}
	if r.privacySettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "privacy_settings", r.privacySettings, "form", "")
	}
	if r.jailbroken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jailbroken", r.jailbroken, "form", "")
	}
	if r.frida != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "frida", r.frida, "form", "")
	}
	if r.factoryReset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "factory_reset", r.factoryReset, "form", "")
	}
	if r.clonedApp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloned_app", r.clonedApp, "form", "")
	}
	if r.emulator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emulator", r.emulator, "form", "")
	}
	if r.rootApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "root_apps", r.rootApps, "form", "")
	}
	if r.vPNConfidence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vpn_confidence", r.vPNConfidence, "form", "")
	}
	if r.minSuspectScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_suspect_score", r.minSuspectScore, "form", "")
	}
	if r.developerTools != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "developer_tools", r.developerTools, "form", "")
	}
	if r.locationSpoofing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location_spoofing", r.locationSpoofing, "form", "")
	}
	if r.mITMAttack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitm_attack", r.mITMAttack, "form", "")
	}
	if r.proxy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxy", r.proxy, "form", "")
	}
	if r.sDKVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sdk_version", r.sDKVersion, "form", "")
	}
	if r.sDKPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sdk_platform", r.sDKPlatform, "form", "")
	}
	if r.environment != nil {
		t := *r.environment
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "environment", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "environment", t, "form", "multi")
		}
	}
	if r.proximityID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proximity_id", r.proximityID, "form", "")
	}
	if r.totalHits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total_hits", r.totalHits, "form", "")
	}
	if r.torNode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tor_node", r.torNode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEventRequest struct {
	ApiService  *FingerprintAPIService
	eventID     string
	eventUpdate *EventUpdate
}

func (r ApiUpdateEventRequest) EventUpdate(eventUpdate EventUpdate) ApiUpdateEventRequest {
	r.eventUpdate = &eventUpdate
	return r
}

func (r ApiUpdateEventRequest) Execute(ctx context.Context) (*http.Response, error) {
	return r.ApiService.UpdateEventExecute(ctx, r)
}

/*
UpdateEvent Update an event

Change information in existing events specified by `event_id` or *flag suspicious events*.

When an event is created, it can be assigned `linked_id` and `tags` submitted through the JS agent parameters.
This information might not have been available on the client initially, so the Server API permits updating these attributes after the fact.

**Warning** It's not possible to update events older than one month.

**Warning** Trying to update an event immediately after creation may temporarily result in an
error (HTTP 409 Conflict. The event is not mutable yet.) as the event is fully propagated across our systems. In such a case, simply retry the request.

	@param eventID The unique event [identifier](https://dev.fingerprint.com/reference/get-function#event_id).
	@return ApiUpdateEventRequest
*/
func (a *FingerprintAPIService) UpdateEvent(eventID string) ApiUpdateEventRequest {
	return ApiUpdateEventRequest{
		ApiService: a,
		eventID:    eventID,
	}
}

// Execute executes the request
func (a *FingerprintAPIService) UpdateEventExecute(ctx context.Context, r ApiUpdateEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(ctx, "FingerprintAPIService.UpdateEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{event_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventID, "eventID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventUpdate == nil {
		return nil, reportError("eventUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventUpdate
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
